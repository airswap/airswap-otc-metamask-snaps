{"version":3,"file":"ed25519Bip32.mjs","sourceRoot":"","sources":["../../src/curves/ed25519Bip32.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  stringToBytes,\n  bytesToHex,\n  hexToBigInt,\n  remove0x,\n  assert,\n} from '@metamask/utils';\nimport { mod } from '@noble/curves/abstract/modular';\nimport { ed25519 } from '@noble/curves/ed25519';\n\nexport const curve = ed25519.CURVE;\n\n/**\n * Named after whitepaper: BIP32-Ed25519 Hierarchical Deterministic Keys over a Non-linear Keyspace\n * https://input-output-hk.github.io/adrestia/static/Ed25519_BIP.pdf\n * \"vanilla\" \"ed25519\" curve follows SLIP10: https://tezos.stackexchange.com/questions/2837/can-i-use-bip32-hd-key-pairs-to-derive-ed25519-addresses\n * note that that the important difference of the \"bip32\" version is that it allows unhardened key derivation\n */\nexport const name = 'ed25519Bip32';\n\n// Secret is empty string if not provided by user\nexport const secret = stringToBytes('');\n\n/**\n * Get a byte from a private key at a given index.\n *\n * @param privateKey - The private key.\n * @param index - The index of the byte to get.\n * @returns The byte at the given index.\n * @throws If the private key is too short.\n */\nfunction getByte(privateKey: Uint8Array, index: number): number {\n  const byte = privateKey[index];\n  assert(byte !== undefined, 'Private key is too short.');\n\n  return byte;\n}\n\n/**\n * Check if a private key is valid.\n *\n * @param privateKey - The private key to check.\n * @returns Whether the private key is valid.\n */\nexport const isValidPrivateKey = (privateKey: Uint8Array) => {\n  /* eslint-disable no-bitwise */\n  // Lowest 3 bits of the first byte must be zero\n  if ((getByte(privateKey, 0) & 0b00000111) !== 0) {\n    return false;\n  }\n\n  // The highest bit of the last byte must be zero\n  if ((getByte(privateKey, 31) & 0b10000000) !== 0) {\n    return false;\n  }\n\n  // The second highest bit of the last byte must be one\n  if ((getByte(privateKey, 31) & 0b01000000) !== 0b01000000) {\n    return false;\n  }\n  /* eslint-enable no-bitwise */\n\n  return true;\n};\n\nexport const deriveUnhardenedKeys = true;\n\nexport const publicKeyLength = 32;\n\n/**\n * Converts a Uint8Array of bytes to a bigint in little-endian format.\n *\n * @param bytes - The Uint8Array of bytes to convert.\n * @returns The converted bigint value.\n */\nexport const bytesToNumberLE = (bytes: Uint8Array): bigint => {\n  return hexToBigInt(bytesToHex(Uint8Array.from(bytes).reverse()));\n};\n\n/**\n * Multiplies the given key with the base point on the Edwards curve.\n * equivalent to https://github.com/jedisct1/libsodium/blob/93a6e79750a31bc0b946bf483b2ba1c77f9e94ce/src/libsodium/crypto_scalarmult/ed25519/ref10/scalarmult_ed25519_ref10.c#L105 .\n * which is used by cardano-js-sdk/crypto https://github.com/input-output-hk/cardano-js-sdk/blob/8a6db2a251cd1c956f52730a0d35de2b7fc67404/packages/crypto/src/Bip32/Bip32PrivateKey.ts#L161 .\n *\n * @param key - The key to multiply with the base point.\n * @returns The resulting point on the Edwards curve.\n */\nexport const multiplyWithBase = (key: Uint8Array): Uint8Array => {\n  // Little-endian SHA512 with modulo n\n  const scalar = mod(bytesToNumberLE(key), curve.n); // The actual scalar\n  const point = ed25519.ExtendedPoint.BASE.multiply(scalar); // Point on Edwards curve aka public key\n  return point.toRawBytes(); // Uint8Array representation\n};\n\n/**\n * Calculates the public key corresponding to a given private key.\n *\n * @param privateKey - The private key.\n * @param _compressed - Optional parameter to indicate if the public key should be compressed.\n * @returns The public key.\n */\nexport const getPublicKey = async (\n  privateKey: Uint8Array,\n  _compressed?: boolean,\n): Promise<Uint8Array> => {\n  return multiplyWithBase(privateKey.slice(0, 32));\n};\n\n/**\n * Adds a tweak to a public key.\n *\n * @param publicKey - The public key.\n * @param tweak - The tweak to add.\n * @returns The resulting public key.\n */\nexport const publicAdd = (\n  publicKey: Uint8Array,\n  tweak: Uint8Array,\n): Uint8Array => {\n  return ed25519.ExtendedPoint.fromHex(remove0x(bytesToHex(publicKey)))\n    .add(ed25519.ExtendedPoint.fromHex(remove0x(bytesToHex(tweak))))\n    .toRawBytes();\n};\n\n/**\n * Compresses an Ed25519 public key.\n *\n * @param publicKey - The public key to compress.\n * @returns The compressed public key.\n */\nexport const compressPublicKey = (publicKey: Uint8Array): Uint8Array => {\n  // Ed25519 public keys don't have a compressed form.\n  return publicKey;\n};\n\n/**\n * Decompresses a compressed Ed25519Bip32 public key.\n *\n * @param publicKey - The compressed public key.\n * @returns The decompressed public key.\n */\nexport const decompressPublicKey = (publicKey: Uint8Array): Uint8Array => {\n  // Ed25519 public keys don't have a compressed form.\n  return publicKey;\n};\n\nexport const privateKeyLength = 64;\n\nexport const masterNodeGenerationSpec = 'cip3';\n\nexport const compressedPublicKeyLength = 32;\n"]}