{"version":3,"sources":["../src/errors.ts","../src/internals/error-wrappers.ts","../src/internals/errors.ts","../src/internals/structs.ts","../src/internals/jsx.ts","../src/internals/svg.ts","../src/index.ts","../src/error-wrappers.ts","../src/images.ts","../src/ui/components/address.ts","../src/ui/builder.ts","../src/ui/nodes.ts","../src/ui/components/copyable.ts","../src/ui/components/divider.ts","../src/ui/components/heading.ts","../src/ui/components/image.ts","../src/ui/components/panel.ts","../src/ui/components/button.ts","../src/ui/components/form.ts","../src/ui/components/input.ts","../src/ui/components/row.ts","../src/ui/components/text.ts","../src/ui/components/spinner.ts","../src/ui/component.ts","../src/types/handlers/transaction.ts","../src/types/handlers/user-input.ts","../src/types/methods/dialog.ts","../src/types/methods/get-file.ts","../src/types/methods/manage-state.ts","../src/types/methods/notify.ts","../src/types/interface.ts","../src/jsx/validation.ts"],"sourcesContent":["import type { Json, JsonRpcError } from '@metamask/utils';\n\nimport {\n  getErrorCode,\n  getErrorData,\n  getErrorMessage,\n  SNAP_ERROR_CODE,\n  SNAP_ERROR_MESSAGE,\n} from './internals';\n\n/**\n * A generic error which can be thrown by a Snap, without it causing the Snap to\n * crash.\n */\nexport class SnapError extends Error {\n  readonly #code: number;\n\n  readonly #message: string;\n\n  readonly #data?: Record<string, Json>;\n\n  readonly #stack?: string;\n\n  /**\n   * Create a new `SnapError`.\n   *\n   * @param error - The error to create the `SnapError` from. If this is a\n   * `string`, it will be used as the error message. If this is an `Error`, its\n   * `message` property will be used as the error message. If this is a\n   * `JsonRpcError`, its `message` property will be used as the error message\n   * and its `code` property will be used as the error code. Otherwise, the\n   * error will be converted to a string and used as the error message.\n   * @param data - Additional data to include in the error. This will be merged\n   * with the error data, if any.\n   */\n  constructor(\n    error: string | Error | JsonRpcError,\n    data: Record<string, Json> = {},\n  ) {\n    const message = getErrorMessage(error);\n    super(message);\n\n    this.#message = message;\n    this.#code = getErrorCode(error);\n\n    const mergedData = { ...getErrorData(error), ...data };\n    if (Object.keys(mergedData).length > 0) {\n      this.#data = mergedData;\n    }\n\n    this.#stack = super.stack;\n  }\n\n  /**\n   * The error name.\n   *\n   * @returns The error name.\n   */\n  get name() {\n    return 'SnapError';\n  }\n\n  /**\n   * The error code.\n   *\n   * @returns The error code.\n   */\n  get code() {\n    return this.#code;\n  }\n\n  /**\n   * The error message.\n   *\n   * @returns The error message.\n   */\n  // This line is covered, but Jest doesn't pick it up for some reason.\n  /* istanbul ignore next */\n  get message() {\n    return this.#message;\n  }\n\n  /**\n   * Additional data for the error.\n   *\n   * @returns Additional data for the error.\n   */\n  get data() {\n    return this.#data;\n  }\n\n  /**\n   * The error stack.\n   *\n   * @returns The error stack.\n   */\n  // This line is covered, but Jest doesn't pick it up for some reason.\n  /* istanbul ignore next */\n  get stack() {\n    return this.#stack;\n  }\n\n  /**\n   * Convert the error to a JSON object.\n   *\n   * @returns The JSON object.\n   */\n  toJSON(): SerializedSnapError {\n    return {\n      code: SNAP_ERROR_CODE,\n      message: SNAP_ERROR_MESSAGE,\n      data: {\n        cause: {\n          code: this.code,\n          message: this.message,\n          stack: this.stack,\n          ...(this.data ? { data: this.data } : {}),\n        },\n      },\n    };\n  }\n\n  /**\n   * Serialize the error to a JSON object. This is called by\n   * `@metamask/rpc-errors` when serializing the error.\n   *\n   * @returns The JSON object.\n   */\n  serialize() {\n    return this.toJSON();\n  }\n}\n\n/**\n * A serialized {@link SnapError}. It's JSON-serializable, so it can be sent\n * over the RPC. The original error is wrapped in the `cause` property.\n *\n * @property code - The error code. This is always `-31002`.\n * @property message - The error message. This is always `'Snap Error'`.\n * @property data - The error data.\n * @property data.cause - The cause of the error.\n * @property data.cause.code - The error code.\n * @property data.cause.message - The error message.\n * @property data.cause.stack - The error stack.\n * @property data.cause.data - Additional data for the error.\n * @see SnapError\n */\nexport type SerializedSnapError = {\n  code: typeof SNAP_ERROR_CODE;\n  message: typeof SNAP_ERROR_MESSAGE;\n  data: {\n    cause: JsonRpcError;\n  };\n};\n","import type { rpcErrors } from '@metamask/rpc-errors';\nimport type { Json } from '@metamask/utils';\n\nimport { SnapError } from '../errors';\n\nexport type JsonRpcErrorFunction = typeof rpcErrors.parse;\n\n/**\n * Create a `SnapError` class from an error function from\n * `@metamask/rpc-errors`. This is useful for creating custom error classes\n * which can be thrown by a Snap.\n *\n * The created class will inherit the message, code, and data properties from\n * the error function.\n *\n * @param fn - The error function to create the class from.\n * @returns The created `SnapError` class.\n */\nexport function createSnapError(fn: JsonRpcErrorFunction) {\n  return class SnapJsonRpcError extends SnapError {\n    /**\n     * Create a new `SnapJsonRpcError` from a message.\n     *\n     * @param message - The message to create the error from.\n     */\n    constructor(message?: string);\n\n    /**\n     * Create a new `SnapJsonRpcError` from data.\n     *\n     * @param data - The data to create the error from.\n     */\n    constructor(data?: Record<string, Json>);\n\n    /**\n     * Create a new `SnapJsonRpcError` from a message and data.\n     *\n     * @param message - The message to create the error from.\n     * @param data - The data to create the error from.\n     */\n    constructor(\n      message?: string | Record<string, Json>,\n      data?: Record<string, Json>,\n    );\n\n    /**\n     * Create a new `SnapJsonRpcError` from a message and data.\n     *\n     * @param message - The message to create the error from.\n     * @param data - The data to create the error from.\n     */\n    constructor(\n      message?: string | Record<string, Json>,\n      data?: Record<string, Json>,\n    ) {\n      if (typeof message === 'object') {\n        const error = fn();\n        super({\n          code: error.code,\n          message: error.message,\n          data: message,\n        });\n\n        return;\n      }\n\n      const error = fn(message);\n      super({\n        code: error.code,\n        message: error.message,\n        data,\n      });\n    }\n  };\n}\n","import { hasProperty, isObject, isValidJson } from '@metamask/utils';\n\nexport const SNAP_ERROR_CODE = -31002;\nexport const SNAP_ERROR_MESSAGE = 'Snap Error';\n\n/**\n * Get the error message from an unknown error type.\n *\n * - If the error is an object with a `message` property, return the message.\n * - Otherwise, return the error converted to a string.\n *\n * @param error - The error to get the message from.\n * @returns The error message.\n * @internal\n */\nexport function getErrorMessage(error: unknown) {\n  if (\n    isObject(error) &&\n    hasProperty(error, 'message') &&\n    typeof error.message === 'string'\n  ) {\n    return error.message;\n  }\n\n  return String(error);\n}\n\n/**\n * Get the error stack from an unknown error type.\n *\n * @param error - The error to get the stack from.\n * @returns The error stack, or undefined if the error does not have a valid\n * stack.\n * @internal\n */\nexport function getErrorStack(error: unknown) {\n  if (\n    isObject(error) &&\n    hasProperty(error, 'stack') &&\n    typeof error.stack === 'string'\n  ) {\n    return error.stack;\n  }\n\n  return undefined;\n}\n\n/**\n * Get the error code from an unknown error type.\n *\n * @param error - The error to get the code from.\n * @returns The error code, or `-32603` if the error does not have a valid code.\n * @internal\n */\nexport function getErrorCode(error: unknown) {\n  if (\n    isObject(error) &&\n    hasProperty(error, 'code') &&\n    typeof error.code === 'number' &&\n    Number.isInteger(error.code)\n  ) {\n    return error.code;\n  }\n\n  return -32603;\n}\n\n/**\n * Get the error data from an unknown error type.\n *\n * @param error - The error to get the data from.\n * @returns The error data, or an empty object if the error does not have valid\n * data.\n * @internal\n */\nexport function getErrorData(error: unknown) {\n  if (\n    isObject(error) &&\n    hasProperty(error, 'data') &&\n    typeof error.data === 'object' &&\n    error.data !== null &&\n    isValidJson(error.data) &&\n    !Array.isArray(error.data)\n  ) {\n    return error.data;\n  }\n\n  return {};\n}\n","import type { AnyStruct, Infer, InferStructTuple } from '@metamask/superstruct';\nimport {\n  Struct,\n  define,\n  is,\n  literal as superstructLiteral,\n  union as superstructUnion,\n} from '@metamask/superstruct';\nimport { hasProperty, isPlainObject } from '@metamask/utils';\n\nimport type { EnumToUnion } from './helpers';\n\n/**\n * A wrapper of `superstruct`'s `literal` struct that also defines the name of\n * the struct as the literal value.\n *\n * This is useful for improving the error messages returned by `superstruct`.\n * For example, instead of returning an error like:\n *\n * ```\n * Expected the value to satisfy a union of `literal | literal`, but received: \\\"baz\\\"\n * ```\n *\n * This struct will return an error like:\n *\n * ```\n * Expected the value to satisfy a union of `\"foo\" | \"bar\"`, but received: \\\"baz\\\"\n * ```\n *\n * @param value - The literal value.\n * @returns The `superstruct` struct, which validates that the value is equal\n * to the literal value.\n */\nexport function literal<Type extends string | number | boolean>(value: Type) {\n  return define<Type>(\n    JSON.stringify(value),\n    superstructLiteral(value).validator,\n  );\n}\n\n/**\n * A wrapper of `superstruct`'s `union` struct that also defines the schema as\n * the union of the schemas of the structs.\n *\n * This is useful for improving the error messages returned by `superstruct`.\n *\n * @param structs - The structs to union.\n * @param structs.\"0\" - The first struct.\n * @param structs.\"1\" - The remaining structs.\n * @returns The `superstruct` struct, which validates that the value satisfies\n * one of the structs.\n */\nexport function union<Head extends AnyStruct, Tail extends AnyStruct[]>([\n  head,\n  ...tail\n]: [head: Head, ...tail: Tail]): Struct<\n  Infer<Head> | InferStructTuple<Tail>[number],\n  [head: Head, ...tail: Tail]\n> {\n  const struct = superstructUnion([head, ...tail]);\n\n  return new Struct({\n    ...struct,\n    schema: [head, ...tail],\n  });\n}\n\n/**\n * Superstruct struct for validating an enum value. This allows using both the\n * enum string values and the enum itself as values.\n *\n * @param constant - The enum to validate against.\n * @returns The superstruct struct.\n */\nexport function enumValue<Type extends string>(\n  constant: Type,\n): Struct<EnumToUnion<Type>, null> {\n  return literal(constant as EnumToUnion<Type>);\n}\n\n/**\n * Create a custom union struct that validates exclusively based on a `type` field.\n *\n * This should improve error messaging for unions with many structs in them.\n *\n * @param structs - The structs to union.\n * @returns The `superstruct` struct, which validates that the value satisfies\n * one of the structs.\n */\nexport function typedUnion<Head extends AnyStruct, Tail extends AnyStruct[]>(\n  structs: [head: Head, ...tail: Tail],\n): Struct<Infer<Head> | InferStructTuple<Tail>[number], null> {\n  return new Struct({\n    type: 'union',\n    schema: null,\n    *entries(value, context) {\n      if (!isPlainObject(value) || !hasProperty(value, 'type')) {\n        return;\n      }\n\n      const { type } = value;\n      const struct = structs.find(({ schema }) => is(type, schema.type));\n\n      if (!struct) {\n        return;\n      }\n\n      for (const entry of struct.entries(value, context)) {\n        yield entry;\n      }\n    },\n    validator(value, context) {\n      const types = structs.map(({ schema }) => schema.type.type);\n\n      if (\n        !isPlainObject(value) ||\n        !hasProperty(value, 'type') ||\n        typeof value.type !== 'string'\n      ) {\n        return `Expected type to be one of: ${types.join(\n          ', ',\n        )}, but received: undefined`;\n      }\n\n      const { type } = value;\n\n      const struct = structs.find(({ schema }) => is(type, schema.type));\n\n      if (struct) {\n        // This only validates the root of the struct, entries does the rest of the work.\n        return struct.validator(value, context);\n      }\n\n      return `Expected type to be one of: ${types.join(\n        ', ',\n      )}, but received: \"${type}\"`;\n    },\n  }) as unknown as Struct<Infer<Head> | InferStructTuple<Tail>[number], null>;\n}\n","import type {\n  AnyStruct,\n  EnumSchema,\n  Infer,\n  InferStructTuple,\n  IsExactMatch,\n  IsMatch,\n  IsRecord,\n  IsTuple,\n  Struct,\n  UnionToIntersection,\n} from '@metamask/superstruct';\n\nimport type { EmptyObject } from '../types';\nimport { union } from './structs';\n\n/**\n * Check if a type is a union. Infers `true` if it is a union, otherwise\n * `false`.\n */\ntype IsUnion<Type> = [Type] extends [UnionToIntersection<Type>] ? false : true;\n\n/**\n * Get a struct schema for a type.\n *\n * This is copied from `superstruct` but fixes some issues with the original\n * implementation.\n */\ntype StructSchema<Type> = IsUnion<Type> extends true\n  ? null\n  : [Type] extends [EmptyObject]\n  ? EmptyObject\n  : [Type] extends [string | undefined | null]\n  ? [Type] extends [`0x${string}`]\n    ? null\n    : [Type] extends [IsMatch<Type, string | undefined | null>]\n    ? null\n    : [Type] extends [IsUnion<Type>]\n    ? EnumSchema<Type>\n    : Type\n  : [Type] extends [number | undefined | null]\n  ? [Type] extends [IsMatch<Type, number | undefined | null>]\n    ? null\n    : [Type] extends [IsUnion<Type>]\n    ? EnumSchema<Type>\n    : Type\n  : [Type] extends [boolean]\n  ? [Type] extends [IsExactMatch<Type, boolean>]\n    ? null\n    : Type\n  : Type extends\n      | bigint\n      | symbol\n      | undefined\n      | null\n      // eslint-disable-next-line @typescript-eslint/ban-types\n      | Function\n      | Date\n      | Error\n      | RegExp\n      | Map<any, any>\n      | WeakMap<any, any>\n      | Set<any>\n      | WeakSet<any>\n      | Promise<any>\n  ? null\n  : Type extends (infer E)[]\n  ? Type extends IsTuple<Type>\n    ? null\n    : Struct<E>\n  : Type extends object\n  ? Type extends IsRecord<Type>\n    ? null\n    : {\n        [InnerKey in keyof Type]: Describe<Type[InnerKey]>;\n      }\n  : null;\n\n/**\n * Describe a struct type.\n */\nexport type Describe<Type> = Struct<Type, StructSchema<Type>>;\n\n/**\n * Create a union struct that uses `null` for the schema type, for better\n * compatibility with `Describe`.\n *\n * @param structs - The structs to union.\n * @returns The `superstruct` struct, which validates that the value satisfies\n * one of the structs.\n */\nexport function nullUnion<Head extends AnyStruct, Tail extends AnyStruct[]>(\n  structs: [head: Head, ...tail: Tail],\n): Struct<Infer<Head> | InferStructTuple<Tail>[number], null> {\n  return union(structs) as unknown as Struct<\n    Infer<Head> | InferStructTuple<Tail>[number],\n    null\n  >;\n}\n","import { refine, string } from '@metamask/superstruct';\n\n/**\n * Get a Struct that validates a string as a valid SVG.\n *\n * @returns A Struct that validates a string as a valid SVG.\n * @internal\n */\nexport function svg() {\n  return refine(string(), 'SVG', (value) => {\n    // This validation is intentionally very basic, we don't need to be that strict\n    // and merely have this extra validation as a helpful error if devs aren't\n    // passing in SVGs.\n    if (!value.includes('<svg')) {\n      return 'Value is not a valid SVG.';\n    }\n\n    return true;\n  });\n}\n","// Only internals that are used by other Snaps packages should be exported here.\nexport type { EnumToUnion } from './internals';\nexport {\n  getErrorData,\n  getErrorMessage,\n  getErrorStack,\n  SNAP_ERROR_CODE,\n  SNAP_ERROR_MESSAGE,\n  literal,\n  union,\n  enumValue,\n} from './internals';\n\n// Re-exported from `@metamask/utils` for convenience.\nexport type {\n  Json,\n  JsonRpcError,\n  JsonRpcRequest,\n  JsonRpcParams,\n} from '@metamask/utils';\nexport { assert } from '@metamask/utils';\n\nexport * from './errors';\nexport * from './error-wrappers';\nexport * from './images';\nexport * from './types';\nexport * from './ui';\n","import { providerErrors, rpcErrors } from '@metamask/rpc-errors';\n\nimport { createSnapError } from './internals';\n\n/**\n * A JSON-RPC 2.0 Internal (-32603) error.\n *\n * This can be thrown by a Snap to indicate that an internal error occurred,\n * without crashing the Snap.\n *\n * @see https://www.jsonrpc.org/specification#error_object\n */\nexport const InternalError = createSnapError(rpcErrors.internal);\n\n/**\n * An Ethereum JSON-RPC Invalid Input (-32000) error.\n *\n * This can be thrown by a Snap to indicate that the input to a method is\n * invalid, without crashing the Snap.\n *\n * @see https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport const InvalidInputError = createSnapError(rpcErrors.invalidInput);\n\n/**\n * A JSON-RPC 2.0 Invalid Params (-32602) error.\n *\n * This can be thrown by a Snap to indicate that the parameters to a method are\n * invalid, without crashing the Snap.\n *\n * @see https://www.jsonrpc.org/specification#error_object\n */\nexport const InvalidParamsError = createSnapError(rpcErrors.invalidParams);\n\n/**\n * A JSON-RPC 2.0 Invalid Request (-32600) error.\n *\n * This can be thrown by a Snap to indicate that the request is invalid, without\n * crashing the Snap.\n *\n * @see https://www.jsonrpc.org/specification#error_object\n */\nexport const InvalidRequestError = createSnapError(rpcErrors.invalidRequest);\n\n/**\n * An Ethereum JSON-RPC Limit Exceeded (-32005) error.\n *\n * This can be thrown by a Snap to indicate that a limit has been exceeded,\n * without crashing the Snap.\n *\n * @see https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport const LimitExceededError = createSnapError(rpcErrors.limitExceeded);\n\n/**\n * An Ethereum JSON-RPC Method Not Found (-32601) error.\n *\n * This can be thrown by a Snap to indicate that a method does not exist,\n * without crashing the Snap.\n *\n * @see https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport const MethodNotFoundError = createSnapError(rpcErrors.methodNotFound);\n\n/**\n * An Ethereum JSON-RPC Method Not Supported (-32004) error.\n *\n * This can be thrown by a Snap to indicate that a method is not supported,\n * without crashing the Snap.\n */\nexport const MethodNotSupportedError = createSnapError(\n  rpcErrors.methodNotSupported,\n);\n\n/**\n * A JSON-RPC 2.0 Parse (-32700) error.\n *\n * This can be thrown by a Snap to indicate that a request is not valid JSON,\n * without crashing the Snap.\n *\n * @see https://www.jsonrpc.org/specification#error_object\n */\nexport const ParseError = createSnapError(rpcErrors.parse);\n\n/**\n * An Ethereum JSON-RPC Resource Not Found (-32001) error.\n *\n * This can be thrown by a Snap to indicate that a resource does not exist,\n * without crashing the Snap.\n *\n * @see https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport const ResourceNotFoundError = createSnapError(\n  rpcErrors.resourceNotFound,\n);\n\n/**\n * An Ethereum JSON-RPC Resource Unavailable (-32002) error.\n *\n * This can be thrown by a Snap to indicate that a resource is unavailable,\n * without crashing the Snap.\n *\n * @see https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport const ResourceUnavailableError = createSnapError(\n  rpcErrors.resourceUnavailable,\n);\n\n/**\n * An Ethereum JSON-RPC Transaction Rejected (-32003) error.\n *\n * This can be thrown by a Snap to indicate that a transaction was rejected,\n * without crashing the Snap.\n *\n * @see https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport const TransactionRejected = createSnapError(\n  rpcErrors.transactionRejected,\n);\n\n/**\n * An Ethereum Provider Chain Disconnected (4901) error.\n *\n * This can be thrown by a Snap to indicate that the provider is disconnected\n * from the requested chain, without crashing the Snap.\n *\n * @see https://eips.ethereum.org/EIPS/eip-1193#provider-errors\n */\nexport const ChainDisconnectedError = createSnapError(\n  providerErrors.chainDisconnected,\n);\n\n/**\n * An Ethereum Provider Disconnected (4900) error.\n *\n * This can be thrown by a Snap to indicate that the provider is disconnected,\n * without crashing the Snap.\n *\n * @see https://eips.ethereum.org/EIPS/eip-1193#provider-errors\n */\nexport const DisconnectedError = createSnapError(providerErrors.disconnected);\n\n/**\n * An Ethereum Provider Unauthorized (4100) error.\n *\n * This can be thrown by a Snap to indicate that the requested method / account\n * is not authorized by the user, without crashing the Snap.\n */\nexport const UnauthorizedError = createSnapError(providerErrors.unauthorized);\n\n/**\n * An Ethereum Provider Unsupported Method (4200) error.\n *\n * This can be thrown by a Snap to indicate that the requested method is not\n * supported by the provider, without crashing the Snap.\n *\n * @see https://eips.ethereum.org/EIPS/eip-1193#provider-errors\n */\nexport const UnsupportedMethodError = createSnapError(\n  providerErrors.unsupportedMethod,\n);\n\n/**\n * An Ethereum Provider User Rejected Request (4001) error.\n *\n * This can be thrown by a Snap to indicate that the user rejected the request,\n * without crashing the Snap.\n *\n * @see https://eips.ethereum.org/EIPS/eip-1193#provider-errors\n */\nexport const UserRejectedRequestError = createSnapError(\n  providerErrors.userRejectedRequest,\n);\n","import { assert, bytesToBase64 } from '@metamask/utils';\n\nimport { image } from './ui';\n\n/**\n * Get raw image data from a URL.\n *\n * @param url - The URL to get the image data from.\n * @param options - The options to use when fetching the image data. This is\n * passed directly to `fetch`.\n * @returns A promise that resolves to the image data as a blob.\n */\nasync function getRawImageData(url: string, options?: RequestInit) {\n  if (typeof fetch !== 'function') {\n    throw new Error(\n      `Failed to fetch image data from \"${url}\": Using this function requires the \"endowment:network-access\" permission.`,\n    );\n  }\n\n  return fetch(url, options).then(async (response) => {\n    if (!response.ok) {\n      throw new Error(\n        `Failed to fetch image data from \"${url}\": ${response.status} ${response.statusText}`,\n      );\n    }\n\n    const blob = await response.blob();\n    assert(\n      blob.type === 'image/jpeg' || blob.type === 'image/png',\n      'Expected image data to be a JPEG or PNG image.',\n    );\n\n    return blob;\n  });\n}\n\n/**\n * Get image data as data-string from a URL. This is useful for embedding images\n * inside of SVGs. Only JPEG and PNG images are supported.\n *\n * Note: This function uses `fetch` to get the image data. This means that using\n * it requires the `endowment:network-access` permission.\n *\n * @example\n * const imageData = await getImageData('https://cataas.com/cat');\n * const svg = `\n *   <svg width=\"100\" height=\"100\" xmlns=\"http://www.w3.org/2000/svg\">\n *     <image href=\"${imageData}\" />\n *   </svg>\n * `;\n *\n * // Render the SVG in a Snap UI.\n * const ui = image(svg);\n * @param url - The URL to get the image data from.\n * @param options - The options to use when fetching the image data. This is\n * passed directly to `fetch`.\n * @returns A promise that resolves to the image data as a data-string.\n */\nexport async function getImageData(url: string, options?: RequestInit) {\n  const blob = await getRawImageData(url, options);\n  const bytes = new Uint8Array(await blob.arrayBuffer());\n\n  return `data:${blob.type};base64,${bytesToBase64(bytes)}`;\n}\n\n/**\n * Options for getting an SVG image element from a URL.\n *\n * @property width - The width of the image.\n * @property height - The height of the image. If this is not provided, the\n * width will be used as the height.\n * @property request - The options to use when fetching the image data. This is\n * passed directly to `fetch`.\n */\nexport type ImageOptions = {\n  width: number;\n  height?: number;\n  request?: RequestInit;\n};\n\n/**\n * Get an image component from a URL. This is useful for embedding images inside\n * Snap UIs. Only JPEG and PNG images are supported.\n *\n * Note: This function uses `fetch` to get the image data. This means that using\n * it requires the `endowment:network-access` permission.\n *\n * @example\n * const component = await getImage('https://cataas.com/cat');\n *\n * return await snap.request({\n *   method: 'snap_dialog',\n *   params: {\n *     type: 'alert',\n *     content: panel([\n *       component,\n *     ]),\n *   },\n * });\n * @param url - The URL to get the image data from.\n * @param options - The options to use when fetching and rendering the image.\n * @param options.width - The width of the image.\n * @param options.height - The height of the image. If this is not provided, the\n * width will be used as the height.\n * @param options.request - The options to use when fetching the image data.\n * This is passed directly to `fetch`.\n * @returns A promise that resolves to the image data as an image component.\n */\nexport async function getImageComponent(\n  url: string,\n  { width, height = width, request }: ImageOptions,\n) {\n  assert(\n    typeof width === 'number' && width > 0,\n    'Expected width to be a number greater than 0.',\n  );\n\n  assert(\n    typeof height === 'number' && height > 0,\n    'Expected height to be a number greater than 0.',\n  );\n\n  const imageData = await getImageData(url, request);\n  const size = `width=\"${width}\" height=\"${height}\"`;\n\n  return image(\n    `<svg ${size.trim()} xmlns=\"http://www.w3.org/2000/svg\"><image ${size.trim()} href=\"${imageData}\" /></svg>`,\n  );\n}\n","import type { Infer } from '@metamask/superstruct';\nimport { assign, literal, object } from '@metamask/superstruct';\nimport { HexChecksumAddressStruct } from '@metamask/utils';\n\nimport { createBuilder } from '../builder';\nimport { LiteralStruct, NodeType } from '../nodes';\n\nexport const AddressStruct = assign(\n  LiteralStruct,\n  object({\n    type: literal(NodeType.Address),\n    value: HexChecksumAddressStruct,\n  }),\n);\n\n/**\n * A address node, that renders an EVM-like address and its icon.\n *\n * @property type - The type of the node. Must be the string `address`.\n * @property value - The address in hexadecimal, including 0x.\n */\nexport type Address = Infer<typeof AddressStruct>;\n\n/**\n * Create an {@link Address} node.\n *\n * @param args - The node arguments. This can either be a string, or an object\n * with the `value` property.\n * @param args.value - The address to be rendered.\n * @returns The address node as an object.\n * @deprecated Snaps component functions are deprecated, in favor of the new JSX\n * components. This function will be removed in a future release.\n * @example\n * const node = address({ value: '0x4bbeeb066ed09b7aed07bf39eee0460dfa261520' });\n * const node = address('0x4bbeeb066ed09b7aed07bf39eee0460dfa261520');\n */\nexport const address = createBuilder(NodeType.Address, AddressStruct, [\n  'value',\n]);\n","import type { Struct } from '@metamask/superstruct';\nimport { assertStruct, isPlainObject } from '@metamask/utils';\n\nimport type { Component } from './components';\nimport type { NodeType } from './nodes';\n\n/**\n * A function that builds a {@link Component}. This infers the proper args type\n * from the given node.\n *\n * @internal\n */\ntype NodeBuilder<Node extends Component, Keys extends (keyof Node)[]> = Omit<\n  Node,\n  'type'\n> extends Record<string, never>\n  ? (...args: []) => Node\n  : (...args: [Omit<Node, 'type'>] | NodeArrayType<Node, Keys>) => Node;\n\n/**\n * Map from an array of node keys to the corresponding array type.\n *\n * @example\n * type Node = { type: 'node'; a: string; b: number; c: boolean };\n * type Keys = ['a', 'b', 'c'];\n *\n * type NodeArray = NodeArrayType<Node, Keys>; // [string, number, boolean]\n * @internal\n */\ntype NodeArrayType<Node extends Component, Keys extends (keyof Node)[]> = {\n  [Key in keyof Keys]: Node[Keys[Key]];\n};\n\n/**\n * A function that returns a function to \"build\" a {@link Component}. It infers\n * the type of the component from the given struct, and performs validation on\n * the created component.\n *\n * The returned function can handle the node arguments in two ways:\n * 1. As a single object, with the keys corresponding to the node's properties,\n * excluding the `type` property.\n * 2. As an array of arguments, with the order corresponding to the given keys.\n *\n * @param type - The type of the component to build.\n * @param struct - The struct to use to validate the component.\n * @param keys - The keys of the component to use as arguments to the builder.\n * The order of the keys determines the order of the arguments.\n * @returns A function that builds a component of the given type.\n * @internal\n */\nexport function createBuilder<\n  Node extends Component,\n  Keys extends (keyof Node)[] = [],\n>(\n  type: NodeType,\n  struct: Struct<Node>,\n  keys: Keys = [] as unknown as Keys,\n): NodeBuilder<Node, Keys> {\n  return (...args: [Omit<Node, 'type'>] | NodeArrayType<Node, Keys> | []) => {\n    // Node passed as a single object.\n    if (args.length === 1 && isPlainObject(args[0])) {\n      const node = { ...args[0], type };\n\n      // The user could be passing invalid values to the builder, so we need to\n      // validate them as per the component's struct.\n      assertStruct(node, struct, `Invalid ${type} component`);\n      return node;\n    }\n\n    // Node passed as an array of arguments.\n    const node = keys.reduce<Partial<Component>>(\n      (partialNode, key, index) => {\n        if (args[index] !== undefined) {\n          return {\n            ...partialNode,\n            [key]: args[index],\n          };\n        }\n\n        return partialNode;\n      },\n      { type },\n    );\n\n    // The user could be passing invalid values to the builder, so we need to\n    // validate them as per the component's struct.\n    assertStruct(node, struct, `Invalid ${type} component`);\n    return node;\n  };\n}\n","import type { Infer } from '@metamask/superstruct';\nimport { assign, object, string, unknown } from '@metamask/superstruct';\n\n/**\n * The supported node types. This is based on SIP-7.\n *\n * @see https://metamask.github.io/SIPs/SIPS/sip-7\n */\nexport enum NodeType {\n  Copyable = 'copyable',\n  Divider = 'divider',\n  Heading = 'heading',\n  Panel = 'panel',\n  Spinner = 'spinner',\n  // eslint-disable-next-line @typescript-eslint/no-shadow\n  Text = 'text',\n  Image = 'image',\n  Row = 'row',\n  Address = 'address',\n  Button = 'button',\n  Input = 'input',\n  Form = 'form',\n}\n\n/**\n * @internal\n */\nexport const NodeStruct = object({\n  type: string(),\n});\n\n/**\n * The base node type. All nodes extend this type.\n *\n * @property type - The type of the node. See {@link NodeType} for the supported\n * node types.\n * @internal\n */\nexport type Node = Infer<typeof NodeStruct>;\n\n/**\n * @internal\n */\nexport const LiteralStruct = assign(\n  NodeStruct,\n  object({\n    value: unknown(),\n  }),\n);\n\n/**\n * A node with a value. This is used for nodes that render a value, such as\n * {@link Text}.\n *\n * @property type - The type of the node.\n * @property value - The value of the node. The type of the value depends on the\n * node type.\n * @internal\n */\nexport type Literal = Infer<typeof LiteralStruct>;\n","import type { Infer } from '@metamask/superstruct';\nimport {\n  assign,\n  boolean,\n  literal,\n  object,\n  optional,\n  string,\n} from '@metamask/superstruct';\n\nimport { createBuilder } from '../builder';\nimport { LiteralStruct, NodeType } from '../nodes';\n\nexport const CopyableStruct = assign(\n  LiteralStruct,\n  object({\n    type: literal(NodeType.Copyable),\n    value: string(),\n    sensitive: optional(boolean()),\n  }),\n);\n\n/**\n * Text that can be copied to the clipboard. It can optionally be marked as\n * sensitive, in which case it will only be displayed to the user after clicking\n * on the component.\n *\n * @property type - The type of the node. Must be the string `copyable`.\n * @property value - The text to be copied.\n * @property sensitive - Whether the value is sensitive or not. Sensitive values\n * are only displayed to the user after clicking on the component. Defaults to\n * false.\n */\nexport type Copyable = Infer<typeof CopyableStruct>;\n\n/**\n * Create a {@link Copyable} component.\n *\n * @param args - The node arguments. This can either be a string, or an object\n * with the `text` property.\n * @param args.value - The text to be copied.\n * @param args.sensitive - Whether the value is sensitive or not. Sensitive\n * values are only displayed to the user after clicking on the component.\n * Defaults to false.\n * @returns A {@link Copyable} component.\n * @deprecated Snaps component functions are deprecated, in favor of the new JSX\n * components. This function will be removed in a future release.\n * @example\n * const node = copyable('Hello, world!');\n * const node = copyable({ value: 'Hello, world!' });\n */\nexport const copyable = createBuilder(NodeType.Copyable, CopyableStruct, [\n  'value',\n  'sensitive',\n]);\n","import type { Infer } from '@metamask/superstruct';\nimport { assign, literal, object } from '@metamask/superstruct';\n\nimport { createBuilder } from '../builder';\nimport { NodeStruct, NodeType } from '../nodes';\n\nexport const DividerStruct = assign(\n  NodeStruct,\n  object({\n    type: literal(NodeType.Divider),\n  }),\n);\n\n/**\n * A divider node, that renders a line between other nodes.\n */\nexport type Divider = Infer<typeof DividerStruct>;\n\n/**\n * Create a {@link Divider} node.\n *\n * @returns The divider node as object.\n * @deprecated Snaps component functions are deprecated, in favor of the new JSX\n * components. This function will be removed in a future release.\n * @example\n * const node = divider();\n */\nexport const divider = createBuilder(NodeType.Divider, DividerStruct);\n","import type { Infer } from '@metamask/superstruct';\nimport { assign, literal, object, string } from '@metamask/superstruct';\n\nimport { createBuilder } from '../builder';\nimport { LiteralStruct, NodeType } from '../nodes';\n\nexport const HeadingStruct = assign(\n  LiteralStruct,\n  object({\n    type: literal(NodeType.Heading),\n    value: string(),\n  }),\n);\n\n/**\n * A heading node, that renders the text as a heading. The level of the heading\n * is determined by the depth of the heading in the document.\n *\n * @property type - The type of the node, must be the string 'text'.\n * @property value - The text content of the node, either as plain text, or as a\n * markdown string.\n */\nexport type Heading = Infer<typeof HeadingStruct>;\n\n/**\n * Create a {@link Heading} node.\n *\n * @param args - The node arguments. This can either be a string, or an object\n * with the `value` property.\n * @param args.value - The heading text.\n * @returns The heading node as object.\n * @deprecated Snaps component functions are deprecated, in favor of the new JSX\n * components. This function will be removed in a future release.\n * @example\n * const node = heading({ value: 'Hello, world!' });\n * const node = heading('Hello, world!');\n */\nexport const heading = createBuilder(NodeType.Heading, HeadingStruct, [\n  'value',\n]);\n","import type { Infer } from '@metamask/superstruct';\nimport { assign, literal, object } from '@metamask/superstruct';\n\nimport { svg } from '../../internals';\nimport { createBuilder } from '../builder';\nimport { NodeStruct, NodeType } from '../nodes';\n\nexport const ImageStruct = assign(\n  NodeStruct,\n  object({\n    type: literal(NodeType.Image),\n    value: svg(),\n  }),\n);\n\n/**\n * An image node, that renders an SVG image.\n *\n * @property type - The type of the node. Must be the string `image`.\n * @property value - The SVG image to be rendered.\n */\nexport type Image = Infer<typeof ImageStruct>;\n\n/**\n * Create an {@link Image} node.\n *\n * @param args - The node arguments. This can either be a string, or an object\n * with the `value` property.\n * @param args.value - The SVG image to be rendered. Must be a valid SVG string.\n * @returns The image node as object. Other image formats are supported by\n * embedding them as data URLs in the SVG.\n * @deprecated Snaps component functions are deprecated, in favor of the new JSX\n * components. This function will be removed in a future release.\n * @example\n * const node = image({ value: '<svg />' });\n * const node = image('<svg />');\n */\nexport const image = createBuilder(NodeType.Image, ImageStruct, ['value']);\n","import type { Infer, Struct } from '@metamask/superstruct';\nimport { array, assign, lazy, literal, object } from '@metamask/superstruct';\n\nimport { typedUnion } from '../../internals';\nimport { createBuilder } from '../builder';\nimport { NodeStruct, NodeType } from '../nodes';\nimport { AddressStruct } from './address';\nimport { ButtonStruct } from './button';\nimport { CopyableStruct } from './copyable';\nimport { DividerStruct } from './divider';\nimport { FormStruct } from './form';\nimport { HeadingStruct } from './heading';\nimport { ImageStruct } from './image';\nimport { InputStruct } from './input';\nimport { RowStruct } from './row';\nimport { SpinnerStruct } from './spinner';\nimport { TextStruct } from './text';\n\n/**\n * @internal\n */\nexport const ParentStruct = assign(\n  NodeStruct,\n  object({\n    // This node references itself indirectly, so we need to use `lazy()`.\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    children: array(lazy(() => ComponentStruct)),\n  }),\n);\n\n/**\n * A node which supports child nodes. This is used for nodes that render their\n * children, such as {@link Panel}.\n *\n * @property type - The type of the node.\n * @property children - The children of the node\n * @internal\n */\nexport type Parent = Infer<typeof ParentStruct>;\n\n/**\n * @internal\n */\nexport const PanelStruct: Struct<Panel> = assign(\n  ParentStruct,\n  object({\n    type: literal(NodeType.Panel),\n  }),\n);\n\n/**\n * A panel node, which renders its children.\n *\n * @property type - The type of the node, must be the string 'text'.\n * @property value - The text content of the node, either as plain text, or as a\n * markdown string.\n */\n// This node references itself indirectly, so it cannot be inferred.\nexport type Panel = {\n  type: NodeType.Panel;\n  children: Component[];\n};\n\n/**\n * Create a {@link Panel} node.\n *\n * @param args - The node arguments. This can be either an array of children, or\n * an object with a `children` property.\n * @param args.children - The child nodes of the panel. This can be any valid\n * {@link Component}.\n * @returns The panel node as object.\n * @deprecated Snaps component functions are deprecated, in favor of the new JSX\n * components. This function will be removed in a future release.\n * @example\n * const node = panel({\n *  children: [\n *    heading({ text: 'Hello, world!' }),\n *    text({ text: 'This is a panel.' }),\n *  ],\n * });\n *\n * const node = panel([\n *   heading('Hello, world!'),\n *   text('This is a panel.'),\n * ]);\n */\nexport const panel = createBuilder(NodeType.Panel, PanelStruct, ['children']);\n\n// This is defined separately from `Component` to avoid circular dependencies.\nexport const ComponentStruct = typedUnion([\n  CopyableStruct,\n  DividerStruct,\n  HeadingStruct,\n  ImageStruct,\n  PanelStruct,\n  SpinnerStruct,\n  TextStruct,\n  RowStruct,\n  AddressStruct,\n  InputStruct,\n  FormStruct,\n  ButtonStruct,\n]);\n\n/**\n * All supported component types.\n */\nexport type Component = Infer<typeof ComponentStruct>;\n","import type { Infer } from '@metamask/superstruct';\nimport {\n  assign,\n  literal,\n  object,\n  optional,\n  string,\n  union,\n} from '@metamask/superstruct';\n\nimport { enumValue } from '../../internals';\nimport { createBuilder } from '../builder';\nimport { LiteralStruct, NodeType } from '../nodes';\n\nexport enum ButtonVariant {\n  Primary = 'primary',\n  Secondary = 'secondary',\n}\n\nexport enum ButtonType {\n  Button = 'button',\n  Submit = 'submit',\n}\n\nexport const ButtonStruct = assign(\n  LiteralStruct,\n  object({\n    type: literal(NodeType.Button),\n    value: string(),\n    variant: optional(\n      union([\n        enumValue(ButtonVariant.Primary),\n        enumValue(ButtonVariant.Secondary),\n      ]),\n    ),\n    buttonType: optional(\n      union([enumValue(ButtonType.Button), enumValue(ButtonType.Submit)]),\n    ),\n    name: optional(string()),\n  }),\n);\n\n/**\n * A button node, that renders either a primary or a secondary button.\n *\n * @property type - The type of the node, must be the string 'button'.\n * @property variant - The style variant of the node, must be either 'primary' or 'secondary'.\n * @property value - The text content of the node as plain text.\n * @property buttonType - The type of the button, must be either 'button' or 'submit'.\n * @property name - An optional name to identify the button.\n */\nexport type Button = Infer<typeof ButtonStruct>;\n\n/**\n * Create a {@link Button} node.\n *\n * @param args - The node arguments. This can be either a string, or an object\n * with a `value` property. A set of optional properties can be passed.\n * @param args.variant - The optional variant of the button.\n * @param args.value - The text content of the node.\n * @param args.name - The optional name of the button.\n * @returns The text node as object.\n * @deprecated Snaps component functions are deprecated, in favor of the new JSX\n * components. This function will be removed in a future release.\n * @example\n * ```typescript\n * const node = button({  variant: 'primary', text: 'Hello, world!', name: 'myButton' });\n * const node = button('Hello, world!', 'button', 'myButton', 'primary');\n * const node = button('Hello, world!');\n * ```\n */\nexport const button = createBuilder(NodeType.Button, ButtonStruct, [\n  'value',\n  'buttonType',\n  'name',\n  'variant',\n]);\n","import type { Infer } from '@metamask/superstruct';\nimport {\n  array,\n  assign,\n  literal,\n  object,\n  string,\n  union,\n} from '@metamask/superstruct';\n\nimport { createBuilder } from '../builder';\nimport { NodeStruct, NodeType } from '../nodes';\nimport { ButtonStruct } from './button';\nimport { InputStruct } from './input';\n\nexport const FormComponentStruct = union([InputStruct, ButtonStruct]);\n\n/**\n * The subset of nodes allowed as children in the {@link Form} node.\n */\nexport type FormComponent = Infer<typeof FormComponentStruct>;\n\nexport const FormStruct = assign(\n  NodeStruct,\n  object({\n    type: literal(NodeType.Form),\n    children: array(FormComponentStruct),\n    name: string(),\n  }),\n);\n\n/**\n * A form node that takes children {@link FormComponent} nodes and renders a form.\n *\n * @property type - The type of the node. Must be the string `form`.\n * @property children - The children of the node. Only {@link FormComponent} nodes are allowed.\n * @property name - The form name used to identify it.\n */\nexport type Form = Infer<typeof FormStruct>;\n\n/**\n * Create a {@link Form} node.\n *\n * @param args - The node arguments. This can be either an array of children and a string, or\n * an object with a `name` and `children` property.\n * @param args.name - The form name used to identify it.\n * @param args.children - The child nodes of the form. This can be any valid\n * {@link FormComponent}.\n * @returns The form node as object.\n * @deprecated Snaps component functions are deprecated, in favor of the new JSX\n * components. This function will be removed in a future release.\n * @example\n * const node = form({\n *  name: 'myForm',\n *  children: [\n *    input({ name: 'myInput' }),\n *    button({ value: 'Hello, world!' }),\n *  ],\n * });\n *\n * const node = form('myForm', [input('myInput'), button('Hello, world!')]);\n */\nexport const form = createBuilder(NodeType.Form, FormStruct, [\n  'name',\n  'children',\n]);\n","import type { Infer } from '@metamask/superstruct';\nimport {\n  assign,\n  literal,\n  object,\n  optional,\n  string,\n  union,\n} from '@metamask/superstruct';\n\nimport { enumValue } from '../../internals';\nimport { createBuilder } from '../builder';\nimport { LiteralStruct, NodeType } from '../nodes';\n\n/**\n * This replicates the available input types from the metamask extension.\n * https://github.com/MetaMask/metamask-extension/develop/ui/components/component-library/input/input.constants.js\n */\nexport enum InputType {\n  /* eslint-disable @typescript-eslint/no-shadow */\n  Text = 'text',\n  Number = 'number',\n  /* eslint-enable @typescript-eslint/no-shadow */\n  Password = 'password',\n}\n\nexport const InputStruct = assign(\n  LiteralStruct,\n  object({\n    type: literal(NodeType.Input),\n    value: optional(string()),\n    name: string(),\n    inputType: optional(\n      union([\n        enumValue(InputType.Text),\n        enumValue(InputType.Password),\n        enumValue(InputType.Number),\n      ]),\n    ),\n    placeholder: optional(string()),\n    label: optional(string()),\n    error: optional(string()),\n  }),\n);\n\n/**\n * An input node, that renders an input.\n *\n * @property type - The type of the node, must be the string 'input'.\n * @property name - The name for the input.\n * @property value - The value of the input.\n * @property inputType - An optional type, either `text`, `password` or `number`.\n * @property placeholder - An optional input placeholder.\n * @property label - An optional input label.\n * @property error - An optional error text.\n */\nexport type Input = Infer<typeof InputStruct>;\n\n/**\n * Create a {@link Input} node.\n *\n * @param args - The node arguments. This can either be a name and an optional variant, value and placeholder or an object\n * with the properties: `inputType`, `value`, `variant`, `placeholder` and `name`.\n * @param args.name - The name for the input.\n * @param args.value - The value of the input.\n * @param args.inputType - An optional type, either `text`, `password` or `number`.\n * @param args.placeholder - An optional input placeholder.\n * @param args.label - An optional input label.\n * @param args.error - An optional error text.\n * @returns The input node as an object.\n * @deprecated Snaps component functions are deprecated, in favor of the new JSX\n * components. This function will be removed in a future release.\n * @example\n * const node = input('myInput');\n * const node = input('myInput', InputType.Text, 'my placeholder', 'myValue', 'myLabel');\n * const node = input({ name: 'myInput' });\n * const node = input({name: 'myInput', value: 'myValue', inputType: InputType.Password, placeholder: 'placeholder'})\n */\nexport const input = createBuilder(NodeType.Input, InputStruct, [\n  'name',\n  'inputType',\n  'placeholder',\n  'value',\n  'label',\n]);\n","import type { Infer } from '@metamask/superstruct';\nimport {\n  assign,\n  literal,\n  object,\n  string,\n  optional,\n  union,\n} from '@metamask/superstruct';\n\nimport { enumValue } from '../../internals';\nimport { createBuilder } from '../builder';\nimport { LiteralStruct, NodeType } from '../nodes';\nimport { AddressStruct } from './address';\nimport { ImageStruct } from './image';\nimport { TextStruct } from './text';\n\nexport enum RowVariant {\n  Default = 'default',\n  Critical = 'critical',\n  Warning = 'warning',\n}\n\n// A subset of components made available to the row\nconst RowComponentStruct = union([ImageStruct, TextStruct, AddressStruct]);\n\nexport const RowStruct = assign(\n  LiteralStruct,\n  object({\n    type: literal(NodeType.Row),\n    variant: optional(\n      union([\n        enumValue(RowVariant.Default),\n        enumValue(RowVariant.Critical),\n        enumValue(RowVariant.Warning),\n      ]),\n    ),\n    label: string(),\n    value: RowComponentStruct,\n  }),\n);\n\n/**\n * A row node, that renders a row with a label and a value.\n *\n * @property type - The type of the node. Must be the string `row`.\n * @property label - The label for the row.\n * @property value - A sub component to be rendered\n * on one side of the row.\n * @property variant - Optional variant for styling.\n */\nexport type Row = Infer<typeof RowStruct>;\n\n/**\n * Create a {@link Row} node.\n *\n * @param args - The node arguments. This can either be a string, a component and an optional variant or an object\n * with the properties: `label`, `value` and `variant`.\n * @param args.label - The label for the row.\n * @param args.value - Another component, is currently limited to `image`, `text` and `address`.\n * @param args.variant - An optional variant, either `default`, `warning` or `critical`.\n * @returns The row node as an object.\n * @deprecated Snaps component functions are deprecated, in favor of the new JSX\n * components. This function will be removed in a future release.\n * @example\n * const node = row({ label: 'Address', value: address('0x4bbeeb066ed09b7aed07bf39eee0460dfa261520') });\n * const node = row({ label: 'Address', value: address('0x4bbeeb066ed09b7aed07bf39eee0460dfa261520'), variant: RowVariant.Warning });\n * const node = row('Address', address('0x4bbeeb066ed09b7aed07bf39eee0460dfa261520'));\n * const node = row('Address', address('0x4bbeeb066ed09b7aed07bf39eee0460dfa261520'), RowVariant.Warning);\n */\nexport const row = createBuilder(NodeType.Row, RowStruct, [\n  'label',\n  'value',\n  'variant',\n]);\n","import type { Infer } from '@metamask/superstruct';\nimport {\n  assign,\n  boolean,\n  literal,\n  object,\n  optional,\n  string,\n} from '@metamask/superstruct';\n\nimport { createBuilder } from '../builder';\nimport { LiteralStruct, NodeType } from '../nodes';\n\nexport const TextStruct = assign(\n  LiteralStruct,\n  object({\n    type: literal(NodeType.Text),\n    value: string(),\n    markdown: optional(boolean()),\n  }),\n);\n\n/**\n * A text node, that renders the text as one or more paragraphs.\n *\n * @property type - The type of the node, must be the string 'text'.\n * @property value - The text content of the node, either as plain text, or as a\n * markdown string.\n * @property markdown - A flag to enable/disable markdown, if nothing is specified\n * markdown will be enabled.\n */\nexport type Text = Infer<typeof TextStruct>;\n\n/**\n * Create a {@link Text} node.\n *\n * @param args - The node arguments. This can be either a string\n * and a boolean, or an object with a `value` property\n * and an optional `markdown` property.\n * @param args.value - The text content of the node.\n * @param args.markdown - An optional flag to enable or disable markdown. This\n * is enabled by default.\n * @returns The text node as object.\n * @deprecated Snaps component functions are deprecated, in favor of the new JSX\n * components. This function will be removed in a future release.\n * @example\n * const node = text({ value: 'Hello, world!' });\n * const node = text('Hello, world!');\n * const node = text({ value: 'Hello, world!', markdown: false });\n * const node = text('Hello, world!', false);\n */\nexport const text = createBuilder(NodeType.Text, TextStruct, [\n  'value',\n  'markdown',\n]);\n","import type { Infer } from '@metamask/superstruct';\nimport { assign, literal, object } from '@metamask/superstruct';\n\nimport { createBuilder } from '../builder';\nimport { NodeStruct, NodeType } from '../nodes';\n\nexport const SpinnerStruct = assign(\n  NodeStruct,\n  object({\n    type: literal(NodeType.Spinner),\n  }),\n);\n\n/**\n * A spinner node, that renders a spinner, either as a full-screen overlay, or\n * inline when nested inside a {@link Panel}.\n */\nexport type Spinner = Infer<typeof SpinnerStruct>;\n\n/**\n * Create a {@link Spinner} node.\n *\n * @returns The spinner node as object.\n * @deprecated Snaps component functions are deprecated, in favor of the new JSX\n * components. This function will be removed in a future release.\n * @example\n * const node = spinner();\n */\nexport const spinner = createBuilder(NodeType.Spinner, SpinnerStruct);\n","import { is } from '@metamask/superstruct';\nimport { assertStruct } from '@metamask/utils';\n\nimport { ComponentStruct } from './components';\nimport type { Component } from './components';\n\n/**\n * Check if the given value is a {@link Component}. This performs recursive\n * validation of the component's children (if any).\n *\n * @param value - The value to check.\n * @returns `true` if the value is a {@link Component}, `false` otherwise.\n */\nexport function isComponent(value: unknown): value is Component {\n  return is(value, ComponentStruct);\n}\n\n/**\n * Assert that the given value is a {@link Component}. This performs recursive\n * validation of the component's children (if any).\n *\n * @param value - The value to check.\n * @throws If the value is not a {@link Component}.\n */\nexport function assertIsComponent(value: unknown): asserts value is Component {\n  assertStruct(value, ComponentStruct, 'Invalid component');\n}\n","import type { ComponentOrElement } from '..';\nimport type { EnumToUnion } from '../../internals';\nimport type { ChainId } from '../caip';\n\n/**\n * The severity level of content being returned from a transaction insight.\n * Currently only one level is supported:\n *\n * - `critical` - The transaction is critical and should not be submitted by the\n * user.\n */\nexport enum SeverityLevel {\n  Critical = 'critical',\n}\n\n/**\n * An EIP-1559 (type 2) transaction object.\n *\n * @property from - The address the transaction is being sent from.\n * @property to - The address the transaction is being sent to.\n * @property nonce - The nonce of the transaction.\n * @property value - The value of the transaction.\n * @property data - The data of the transaction.\n * @property gas - The gas limit of the transaction.\n * @property maxFeePerGas - The maximum fee per gas of the transaction.\n * @property maxPriorityFeePerGas - The maximum priority fee per gas of the\n * transaction.\n * @property estimateSuggested - The suggested gas price for the transaction.\n * @property estimateUsed - The gas price used for the transaction.\n * @see https://eips.ethereum.org/EIPS/eip-1559\n */\nexport type EIP1559Transaction = {\n  from: string;\n  to: string;\n  nonce: string;\n  value: string;\n  data: string;\n  gas: string;\n  maxFeePerGas: string;\n  maxPriorityFeePerGas: string;\n  estimateSuggested: string;\n  estimateUsed: string;\n};\n\n/**\n * A legacy (type \"0\") transaction object.\n *\n * @property from - The address the transaction is being sent from.\n * @property to - The address the transaction is being sent to.\n * @property nonce - The nonce of the transaction.\n * @property value - The value of the transaction.\n * @property data - The data of the transaction.\n * @property gas - The gas limit of the transaction.\n * @property gasPrice - The gas price of the transaction.\n * @property estimateSuggested - The suggested gas price for the transaction.\n * @property estimateUsed - The gas price used for the transaction.\n */\nexport type LegacyTransaction = {\n  from: string;\n  to: string;\n  nonce: string;\n  value: string;\n  data: string;\n  gas: string;\n  gasPrice: string;\n  estimateSuggested: string;\n  estimateUsed: string;\n};\n\n/**\n * A transaction object. This can be either an EIP-1559 transaction or a legacy\n * transaction.\n *\n * @see EIP1559Transaction\n * @see LegacyTransaction\n */\nexport type Transaction = EIP1559Transaction | LegacyTransaction;\n\n/**\n * The `onTransaction` handler. This is called whenever a transaction is\n * submitted to the snap. It can return insights about the transaction, which\n * will be displayed to the user.\n *\n * Note that using this handler requires the `endowment:transaction-insights`\n * permission.\n *\n * @param args - The request arguments.\n * @param args.transaction - The transaction object, containing the address,\n * value, data, and other properties of the transaction.\n * @param args.chainId - The CAIP-2 {@link ChainId} of the network the\n * transaction is being submitted to.\n * @param args.transactionOrigin - The origin of the transaction. This is the\n * URL of the website that submitted the transaction. This is only available if\n * the Snap has enabled the `allowTransactionOrigin` option in the\n * `endowment:transaction-insight` permission.\n * @returns An object containing insights about the transaction. See\n * {@link OnTransactionResponse}. Can also return `null` if no insights are\n * available.\n */\nexport type OnTransactionHandler = (args: {\n  transaction: Transaction;\n  chainId: ChainId;\n  transactionOrigin?: string;\n}) => Promise<OnTransactionResponse | null>;\n\n/**\n * The response from a Snap's `onTransaction` handler.\n *\n * @property component - A custom UI component, that will be shown in MetaMask.\n * @property id - A Snap interface ID.\n * @property severity - The severity level of the content. Currently only one\n * level is supported: `critical`.\n */\nexport type OnTransactionResponse =\n  | {\n      content: ComponentOrElement;\n      severity?: EnumToUnion<SeverityLevel>;\n    }\n  | {\n      id: string;\n      severity?: EnumToUnion<SeverityLevel>;\n    };\n","import type { Infer } from '@metamask/superstruct';\nimport {\n  number,\n  assign,\n  literal,\n  nullable,\n  object,\n  optional,\n  record,\n  string,\n  union,\n  boolean,\n} from '@metamask/superstruct';\n\nimport type { InterfaceContext } from '../interface';\n\n/**\n * The type of user input event fired.\n * Currently only three events are supported:\n *\n * - `ButtonClickEvent` - A button has been clicked in the UI.\n * - `FormSubmitEvent` - A Form has been submitted in the UI.\n * - `InputChangeEvent` - The value of an input field has changed in the UI.\n * - `FileUploadEvent` - A file has been uploaded in the UI.\n */\nexport enum UserInputEventType {\n  ButtonClickEvent = 'ButtonClickEvent',\n  FormSubmitEvent = 'FormSubmitEvent',\n  InputChangeEvent = 'InputChangeEvent',\n  FileUploadEvent = 'FileUploadEvent',\n}\n\nexport const GenericEventStruct = object({\n  type: string(),\n  name: optional(string()),\n});\n\nexport const ButtonClickEventStruct = assign(\n  GenericEventStruct,\n  object({\n    type: literal(UserInputEventType.ButtonClickEvent),\n    name: optional(string()),\n  }),\n);\n\n/**\n * A button click event fired in the UI. This is passed to the params of the\n * `onUserInput` handler.\n *\n * @property type - The type of event fired. See {@link UserInputEventType} for\n * the different types. This is always `ButtonClickEvent`.\n * @property name - The optional component name that fired the event.\n */\nexport type ButtonClickEvent = Infer<typeof ButtonClickEventStruct>;\n\nexport const FileStruct = object({\n  name: string(),\n  size: number(),\n  contentType: string(),\n  contents: string(),\n});\n\n/**\n * A file object containing the file name, size, content type, and the base64\n * encoded contents of the file.\n *\n * @property name - The name of the file.\n * @property size - The size of the file in bytes.\n * @property contentType - The content type of the file.\n * @property contents - The base64 encoded contents of the file.\n */\nexport type File = Infer<typeof FileStruct>;\n\nexport const FormSubmitEventStruct = assign(\n  GenericEventStruct,\n  object({\n    type: literal(UserInputEventType.FormSubmitEvent),\n    value: record(string(), nullable(union([string(), FileStruct, boolean()]))),\n    name: string(),\n  }),\n);\n\n/**\n * A form submit event, which is fired when a submit button is clicked.\n *\n * @property type - The type of event fired. This is always `FormSubmitEvent`.\n * @property name - The name of the form that was submitted.\n * @property value - The form values submitted as an object. The keys are the\n * names of the form fields and the values are the values of the form fields. If\n * a form field is empty, the value is `null` or an empty string.\n * @property files - The files uploaded in the form. The keys are the names of\n * the file input fields and the values are the file objects containing the file\n * name, size, content type, and the base64 encoded contents of the file. See\n * {@link File}.\n */\nexport type FormSubmitEvent = Infer<typeof FormSubmitEventStruct>;\n\nexport const InputChangeEventStruct = assign(\n  GenericEventStruct,\n  object({\n    type: literal(UserInputEventType.InputChangeEvent),\n    name: string(),\n    value: union([string(), boolean()]),\n  }),\n);\n\n/**\n * An input change event, which is fired when the value of an input field\n * changes.\n *\n * @property type - The type of event fired. This is always `InputChangeEvent`.\n * @property name - The name of the input field that changed.\n * @property value - The new value of the input field.\n */\nexport type InputChangeEvent = Infer<typeof InputChangeEventStruct>;\n\nexport const FileUploadEventStruct = assign(\n  GenericEventStruct,\n  object({\n    type: literal(UserInputEventType.FileUploadEvent),\n    name: string(),\n    file: nullable(FileStruct),\n  }),\n);\n\n/**\n * A file upload event, which is fired when a file is uploaded.\n *\n * @property type - The type of event fired. This is always `FileUploadEvent`.\n * @property name - The name of the file input field that was used to upload the\n * file.\n * @property file - The file object containing the file name, size,\n * content type, and the base64 encoded contents of the file.\n * @see File\n */\nexport type FileUploadEvent = Infer<typeof FileUploadEventStruct>;\n\nexport const UserInputEventStruct = union([\n  ButtonClickEventStruct,\n  FormSubmitEventStruct,\n  InputChangeEventStruct,\n  FileUploadEventStruct,\n]);\n\n/**\n * A user input event fired in the UI. This is passed to the params of the `onUserInput` handler.\n *\n * @property type - The type of event fired. See {@link UserInputEventType} for the different types.\n * @property name - The component name that fired the event. It is optional for\n * an {@link UserInputEventType.ButtonClickEvent}.\n * @property value - The value associated with the event. Only available when an\n * {@link UserInputEventType.FormSubmitEvent} is fired. It contains the form values submitted.\n */\nexport type UserInputEvent =\n  | ButtonClickEvent\n  | FormSubmitEvent\n  | InputChangeEvent\n  | FileUploadEvent;\n\n/**\n * The `onUserInput` handler. This is called when an user input event is fired in the UI.\n *\n * @param args - The user input event.\n * @param args.id - The user interface id.\n * @param args.event - The {@link UserInputEvent} object, containing the data about the fired event.\n */\nexport type OnUserInputHandler = (args: {\n  id: string;\n  event: UserInputEvent;\n  context: InterfaceContext | null;\n}) => Promise<void>;\n","import type { Json } from '@metamask/utils';\n\nimport type { ComponentOrElement } from '..';\nimport type { EnumToUnion } from '../../internals';\n\n/**\n * The type of dialog to display.\n *\n * - `alert` - A dialog with a single button.\n * - `confirmation` - A dialog with two buttons, one to confirm and one to\n * cancel.\n * - `prompt` - A dialog with two buttons and a text input.\n */\nexport enum DialogType {\n  Alert = 'alert',\n  Confirmation = 'confirmation',\n  Prompt = 'prompt',\n}\n\nexport type DefaultDialog =\n  | {\n      id: string;\n    }\n  | { content: ComponentOrElement };\n\n/**\n * An alert dialog.\n *\n * @property type - The type of dialog. Must be `alert`.\n * @property content - The content to display in the dialog.\n * @property id - The Snap interface ID.\n */\nexport type AlertDialog =\n  | {\n      type: EnumToUnion<DialogType.Alert>;\n      content: ComponentOrElement;\n    }\n  | {\n      type: EnumToUnion<DialogType.Alert>;\n      id: string;\n    };\n\n/**\n * A confirmation dialog.\n *\n * @property type - The type of dialog. Must be `confirmation`.\n * @property content - The content to display in the dialog.\n * @property id - The Snap interface ID.\n */\nexport type ConfirmationDialog =\n  | {\n      type: EnumToUnion<DialogType.Confirmation>;\n      content: ComponentOrElement;\n    }\n  | {\n      type: EnumToUnion<DialogType.Confirmation>;\n      id: string;\n    };\n\n/**\n * A prompt dialog.\n *\n * @property type - The type of dialog. Must be `prompt`.\n * @property content - The content to display in the dialog.\n * @property id - The Snap interface ID.\n * @property placeholder - An optional placeholder text to display in the text\n * input.\n */\nexport type PromptDialog =\n  | {\n      type: EnumToUnion<DialogType.Prompt>;\n      content: ComponentOrElement;\n      placeholder?: string;\n    }\n  | {\n      type: EnumToUnion<DialogType.Prompt>;\n      id: string;\n      placeholder?: string;\n    };\n\n/**\n * The request parameters for the `snap_dialog` method.\n *\n * @property type - The type of dialog to display.\n * @property content - The content to display in the dialog.\n * @property id - The Snap interface ID.\n * @property placeholder - The placeholder text to display in the dialog. Only\n * applicable for the `prompt` dialog.\n */\nexport type DialogParams =\n  | AlertDialog\n  | ConfirmationDialog\n  | PromptDialog\n  | DefaultDialog;\n\n/**\n * The result returned by the `snap_dialog` method.\n *\n * - If the dialog is an `alert`, the result is `null`.\n * - If the dialog is a `confirmation`, the result is a boolean indicating\n * whether the user confirmed the dialog.\n * - If the dialog is a `prompt`, the result is the value entered by\n * the user.\n */\nexport type DialogResult = null | boolean | string | Json;\n","import type { EnumToUnion } from '../../internals';\n\n/**\n * The encoding to use when retrieving the file. Defaults to `Base64`.\n */\nexport enum AuxiliaryFileEncoding {\n  Base64 = 'base64',\n  Hex = 'hex',\n  Utf8 = 'utf8',\n}\n\n/**\n * The request parameters for the `snap_getFile` method.\n *\n * @property path - The path to the file to retrieve.\n * @property encoding - The encoding to use when retrieving the file.\n */\nexport type GetFileParams = {\n  path: string;\n  encoding?: EnumToUnion<AuxiliaryFileEncoding>;\n};\n\n/**\n * The result returned by the `snap_getFile` method.\n */\nexport type GetFileResult = string;\n","import type { Json } from '@metamask/utils';\n\nimport type { EnumToUnion } from '../../internals';\n\n/**\n * The operations that can be performed on the state.\n */\nexport enum ManageStateOperation {\n  ClearState = 'clear',\n  GetState = 'get',\n  UpdateState = 'update',\n}\n\n/**\n * The clear state operation, which clears the state.\n *\n * @property operation - The operation to perform on the state. Must be `clear`.\n * @property encrypted - Whether to use the separate encrypted state, or the\n * unencrypted state. Defaults to the encrypted state. Encrypted state can only\n * be used if the extension is unlocked, while unencrypted state can be used\n * whether the extension is locked or unlocked.\n */\nexport type ClearStateOperation = {\n  operation: EnumToUnion<ManageStateOperation.ClearState>;\n  encrypted?: boolean;\n};\n\n/**\n * The get state operation, which retrieves the state.\n *\n * @property operation - The operation to perform on the state. Must be `get`.\n * @property encrypted - Whether to use the separate encrypted state, or the\n * unencrypted state. Defaults to the encrypted state. Encrypted state can only\n * be used if the extension is unlocked, while unencrypted state can be used\n * whether the extension is locked or unlocked.\n */\nexport type GetStateOperation = {\n  operation: EnumToUnion<ManageStateOperation.GetState>;\n  encrypted?: boolean;\n};\n\n/**\n * The update state operation, which updates the state.\n *\n * @property operation - The operation to perform on the state. Must be\n * `update`.\n * @property encrypted - Whether to use the separate encrypted state, or the\n * unencrypted state. Defaults to the encrypted state. Encrypted state can only\n * be used if the extension is unlocked, while unencrypted state can be used\n * whether the extension is locked or unlocked.\n * @property newState - The new state to set.\n */\nexport type UpdateStateOperation = {\n  operation: EnumToUnion<ManageStateOperation.UpdateState>;\n  encrypted?: boolean;\n  newState: Record<string, Json>;\n};\n\n/**\n * The request parameters for the `snap_manageState` method.\n *\n * @property operation - The operation to perform on the state.\n * @property encrypted - Whether to use the separate encrypted state, or the\n * unencrypted state. Defaults to the encrypted state.\n * @property newState - The new state to set. Only applicable for the `set`\n * operation.\n */\nexport type ManageStateParams =\n  | ClearStateOperation\n  | GetStateOperation\n  | UpdateStateOperation;\n\n/**\n * The result returned by the `snap_manageState` method.\n *\n * If the operation is `get`, the result is the state. Otherwise, the result is\n * `null`.\n */\nexport type ManageStateResult = Record<string, Json> | null;\n","import type { EnumToUnion } from '../../internals';\n\n/**\n * The types of notifications that can be displayed.\n *\n * - `InApp` - A notification that is displayed in by the MetaMask extension.\n * - `Native` - A notification that is displayed by the operating system.\n */\nexport enum NotificationType {\n  InApp = 'inApp',\n  Native = 'native',\n}\n\n/**\n * The request parameters for the `snap_notify` method.\n *\n * @property type - The type of notification to display.\n * @property message - The message to display in the notification.\n */\nexport type NotifyParams = {\n  type: EnumToUnion<NotificationType>;\n  message: string;\n};\n\n/**\n * The result returned by the `snap_notify` method.\n *\n * This method does not return anything.\n */\nexport type NotifyResult = null;\n","import type { Infer } from '@metamask/superstruct';\nimport {\n  boolean,\n  nullable,\n  record,\n  string,\n  union,\n} from '@metamask/superstruct';\nimport { JsonStruct } from '@metamask/utils';\n\nimport type { JSXElement } from '../jsx';\nimport { RootJSXElementStruct } from '../jsx';\nimport type { Component } from '../ui';\nimport { ComponentStruct } from '../ui';\nimport { FileStruct } from './handlers';\n\n/**\n * To avoid typing problems with the interface state when manipulating it we\n * have to differentiate the state of a form (that will be contained inside the\n * root state) and the root state since a key in the root stat can contain\n * either the value of an input or a sub-state of a form.\n */\n\nexport const StateStruct = union([FileStruct, string(), boolean()]);\n\nexport const FormStateStruct = record(string(), nullable(StateStruct));\n\nexport const InterfaceStateStruct = record(\n  string(),\n  union([FormStateStruct, nullable(StateStruct)]),\n);\n\nexport type State = Infer<typeof StateStruct>;\nexport type FormState = Infer<typeof FormStateStruct>;\nexport type InterfaceState = Infer<typeof InterfaceStateStruct>;\n\nexport type ComponentOrElement = Component | JSXElement;\nexport const ComponentOrElementStruct = union([\n  ComponentStruct,\n  RootJSXElementStruct,\n]);\n\nexport const InterfaceContextStruct = record(string(), JsonStruct);\nexport type InterfaceContext = Infer<typeof InterfaceContextStruct>;\n","import type {\n  AnyStruct,\n  Infer,\n  InferStructTuple,\n  ObjectSchema,\n  Struct,\n} from '@metamask/superstruct';\nimport {\n  is,\n  boolean,\n  optional,\n  array,\n  lazy,\n  nullable,\n  number,\n  object,\n  record,\n  string,\n  tuple,\n} from '@metamask/superstruct';\nimport {\n  hasProperty,\n  HexChecksumAddressStruct,\n  isPlainObject,\n  JsonStruct,\n} from '@metamask/utils';\n\nimport type { Describe } from '../internals';\nimport { literal, nullUnion, svg, typedUnion } from '../internals';\nimport type { EmptyObject } from '../types';\nimport type {\n  GenericSnapElement,\n  JsonObject,\n  Key,\n  Nestable,\n  SnapElement,\n  SnapsChildren,\n  StringElement,\n} from './component';\nimport type {\n  AddressElement,\n  BoldElement,\n  BoxElement,\n  ButtonElement,\n  CheckboxElement,\n  CardElement,\n  CopyableElement,\n  DividerElement,\n  DropdownElement,\n  OptionElement,\n  FieldElement,\n  FormElement,\n  HeadingElement,\n  ImageElement,\n  InputElement,\n  ItalicElement,\n  JSXElement,\n  LinkElement,\n  RowElement,\n  SpinnerElement,\n  StandardFormattingElement,\n  TextElement,\n  TooltipElement,\n  ValueElement,\n  FileInputElement,\n  ContainerElement,\n  FooterElement,\n} from './components';\n\n/**\n * A struct for the {@link Key} type.\n */\nexport const KeyStruct: Describe<Key> = nullUnion([string(), number()]);\n\n/**\n * A struct for the {@link StringElement} type.\n */\nexport const StringElementStruct: Describe<StringElement> = children([\n  string(),\n]);\n\n/**\n * A struct for the {@link GenericSnapElement} type.\n */\nexport const ElementStruct: Describe<GenericSnapElement> = object({\n  type: string(),\n  props: record(string(), JsonStruct),\n  key: nullable(KeyStruct),\n});\n\n/**\n * A helper function for creating a struct for a {@link Nestable} type.\n *\n * @param struct - The struct for the type to test.\n * @returns The struct for the nestable type.\n */\nfunction nestable<Type, Schema>(\n  struct: Struct<Type, Schema>,\n): Struct<Nestable<Type>, any> {\n  const nestableStruct: Struct<Nestable<Type>> = nullUnion([\n    struct,\n    array(lazy(() => nestableStruct)),\n  ]);\n\n  return nestableStruct;\n}\n\n/**\n * A helper function for creating a struct which allows children of a specific\n * type, as well as `null` and `boolean`.\n *\n * @param structs - The structs to allow as children.\n * @returns The struct for the children.\n */\nfunction children<Head extends AnyStruct, Tail extends AnyStruct[]>(\n  structs: [head: Head, ...tail: Tail],\n): Struct<\n  Nestable<Infer<Head> | InferStructTuple<Tail>[number] | boolean | null>,\n  null\n> {\n  return nestable(nullable(nullUnion([...structs, boolean()])));\n}\n\n/**\n * A helper function for creating a struct for a JSX element.\n *\n * @param name - The name of the element.\n * @param props - The props of the element.\n * @returns The struct for the element.\n */\nfunction element<Name extends string, Props extends ObjectSchema = EmptyObject>(\n  name: Name,\n  props: Props = {} as Props,\n) {\n  return object({\n    type: literal(name) as unknown as Struct<Name, Name>,\n    props: object(props),\n    key: nullable(KeyStruct),\n  });\n}\n\n/**\n * A struct for the {@link ButtonElement} type.\n */\nexport const ButtonStruct: Describe<ButtonElement> = element('Button', {\n  children: StringElementStruct,\n  name: optional(string()),\n  type: optional(nullUnion([literal('button'), literal('submit')])),\n  variant: optional(nullUnion([literal('primary'), literal('destructive')])),\n  disabled: optional(boolean()),\n});\n\n/**\n * A struct for the {@link CheckboxElement} type.\n */\nexport const CheckboxStruct: Describe<CheckboxElement> = element('Checkbox', {\n  name: string(),\n  checked: optional(boolean()),\n  label: optional(string()),\n  variant: optional(nullUnion([literal('default'), literal('toggle')])),\n});\n\n/**\n * A struct for the {@link InputElement} type.\n */\nexport const InputStruct: Describe<InputElement> = element('Input', {\n  name: string(),\n  type: optional(\n    nullUnion([literal('text'), literal('password'), literal('number')]),\n  ),\n  value: optional(string()),\n  placeholder: optional(string()),\n});\n\n/**\n * A struct for the {@link OptionElement} type.\n */\nexport const OptionStruct: Describe<OptionElement> = element('Option', {\n  value: string(),\n  children: string(),\n});\n\n/**\n * A struct for the {@link DropdownElement} type.\n */\nexport const DropdownStruct: Describe<DropdownElement> = element('Dropdown', {\n  name: string(),\n  value: optional(string()),\n  children: children([OptionStruct]),\n});\n\n/**\n * A struct for the {@link FileInputElement} type.\n */\nexport const FileInputStruct: Describe<FileInputElement> = element(\n  'FileInput',\n  {\n    name: string(),\n    accept: nullUnion([optional(array(string()))]),\n    compact: optional(boolean()),\n  },\n);\n\n/**\n * A subset of JSX elements that represent the tuple Button + Input of the Field children.\n */\nconst BUTTON_INPUT = [InputStruct, ButtonStruct] as [\n  typeof InputStruct,\n  typeof ButtonStruct,\n];\n\n/**\n * A subset of JSX elements that are allowed as single children of the Field component.\n */\nconst FIELD_CHILDREN_ARRAY = [\n  InputStruct,\n  DropdownStruct,\n  FileInputStruct,\n  CheckboxStruct,\n] as [\n  typeof InputStruct,\n  typeof DropdownStruct,\n  typeof FileInputStruct,\n  typeof CheckboxStruct,\n];\n\n/**\n * A union of the allowed children of the Field component.\n * This is mainly used in the simulator for validation purposes.\n */\nexport const FieldChildUnionStruct = nullUnion([\n  ...FIELD_CHILDREN_ARRAY,\n  ...BUTTON_INPUT,\n]);\n\n/**\n * A subset of JSX elements that are allowed as children of the Field component.\n */\nconst FieldChildStruct = nullUnion([\n  tuple(BUTTON_INPUT),\n  ...FIELD_CHILDREN_ARRAY,\n]);\n\n/**\n * A struct for the {@link FieldElement} type.\n */\nexport const FieldStruct: Describe<FieldElement> = element('Field', {\n  label: optional(string()),\n  error: optional(string()),\n  children: FieldChildStruct,\n});\n\n/**\n * A subset of JSX elements that are allowed as children of the Form component.\n */\nexport const FormChildStruct = children(\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  [FieldStruct, lazy(() => BoxChildStruct)],\n) as unknown as Struct<SnapsChildren<GenericSnapElement>, null>;\n\n/**\n * A struct for the {@link FormElement} type.\n */\nexport const FormStruct: Describe<FormElement> = element('Form', {\n  children: FormChildStruct,\n  name: string(),\n});\n\n/**\n * A struct for the {@link BoldElement} type.\n */\nexport const BoldStruct: Describe<BoldElement> = element('Bold', {\n  children: children([\n    string(),\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    lazy(() => ItalicStruct) as unknown as Struct<\n      SnapElement<JsonObject, 'Italic'>\n    >,\n  ]),\n});\n\n/**\n * A struct for the {@link ItalicElement} type.\n */\nexport const ItalicStruct: Describe<ItalicElement> = element('Italic', {\n  children: children([\n    string(),\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    lazy(() => BoldStruct) as unknown as Struct<\n      SnapElement<JsonObject, 'Bold'>\n    >,\n  ]),\n});\n\nexport const FormattingStruct: Describe<StandardFormattingElement> = nullUnion([\n  BoldStruct,\n  ItalicStruct,\n]);\n\n/**\n * A struct for the {@link AddressElement} type.\n */\nexport const AddressStruct: Describe<AddressElement> = element('Address', {\n  address: HexChecksumAddressStruct,\n});\n\nexport const BoxChildrenStruct = children(\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  [lazy(() => BoxChildStruct)],\n) as unknown as Struct<SnapsChildren<GenericSnapElement>, null>;\n\n/**\n * A struct for the {@link BoxElement} type.\n */\nexport const BoxStruct: Describe<BoxElement> = element('Box', {\n  children: BoxChildrenStruct,\n  direction: optional(nullUnion([literal('horizontal'), literal('vertical')])),\n  alignment: optional(\n    nullUnion([\n      literal('start'),\n      literal('center'),\n      literal('end'),\n      literal('space-between'),\n      literal('space-around'),\n    ]),\n  ),\n});\n\n/**\n * A subset of JSX elements that are allowed as children of the Footer component.\n * This set should include a single button or a tuple of two buttons.\n */\nexport const FooterChildStruct = nullUnion([\n  tuple([ButtonStruct, ButtonStruct]),\n  ButtonStruct,\n]);\n\n/**\n * A struct for the {@link FooterElement} type.\n */\nexport const FooterStruct: Describe<FooterElement> = element('Footer', {\n  children: FooterChildStruct,\n});\n\n/**\n * A subset of JSX elements that are allowed as children of the Container component.\n * This set should include a single Box or a tuple of a Box and a Footer component.\n */\nexport const ContainerChildStruct = nullUnion([\n  tuple([BoxStruct, FooterStruct]),\n  BoxStruct,\n]);\n\n/**\n * A struct for the {@link ContainerElement} type.\n */\nexport const ContainerStruct: Describe<ContainerElement> = element(\n  'Container',\n  {\n    children: ContainerChildStruct,\n  },\n);\n\n/**\n * A struct for the {@link CopyableElement} type.\n */\nexport const CopyableStruct: Describe<CopyableElement> = element('Copyable', {\n  value: string(),\n  sensitive: optional(boolean()),\n});\n\n/**\n * A struct for the {@link DividerElement} type.\n */\nexport const DividerStruct: Describe<DividerElement> = element('Divider');\n\n/**\n * A struct for the {@link ValueElement} type.\n */\nexport const ValueStruct: Describe<ValueElement> = element('Value', {\n  value: string(),\n  extra: string(),\n});\n\n/**\n * A struct for the {@link CardElement} type.\n */\nexport const CardStruct: Describe<CardElement> = element('Card', {\n  image: optional(string()),\n  title: string(),\n  description: optional(string()),\n  value: string(),\n  extra: optional(string()),\n});\n\n/**\n * A struct for the {@link HeadingElement} type.\n */\nexport const HeadingStruct: Describe<HeadingElement> = element('Heading', {\n  children: StringElementStruct,\n});\n\n/**\n * A struct for the {@link ImageElement} type.\n */\nexport const ImageStruct: Describe<ImageElement> = element('Image', {\n  src: svg(),\n  alt: optional(string()),\n});\n\n/**\n * A struct for the {@link LinkElement} type.\n */\nexport const LinkStruct: Describe<LinkElement> = element('Link', {\n  href: string(),\n  children: children([FormattingStruct, string()]),\n});\n\n/**\n * A struct for the {@link TextElement} type.\n */\nexport const TextStruct: Describe<TextElement> = element('Text', {\n  children: children([string(), BoldStruct, ItalicStruct, LinkStruct]),\n  alignment: optional(\n    nullUnion([literal('start'), literal('center'), literal('end')]),\n  ),\n});\n\n/**\n * A subset of JSX elements that are allowed as children of the Tooltip component.\n * This set should include all text components and the Image.\n */\nexport const TooltipChildStruct = nullUnion([\n  TextStruct,\n  BoldStruct,\n  ItalicStruct,\n  LinkStruct,\n  ImageStruct,\n  boolean(),\n]);\n\n/**\n * A subset of JSX elements that are allowed as content of the Tooltip component.\n * This set should include all text components.\n */\nexport const TooltipContentStruct = nullUnion([\n  TextStruct,\n  BoldStruct,\n  ItalicStruct,\n  LinkStruct,\n  string(),\n]);\n\n/**\n * A struct for the {@link TooltipElement} type.\n */\nexport const TooltipStruct: Describe<TooltipElement> = element('Tooltip', {\n  children: nullable(TooltipChildStruct),\n  content: TooltipContentStruct,\n});\n\n/**\n * A struct for the {@link RowElement} type.\n */\nexport const RowStruct: Describe<RowElement> = element('Row', {\n  label: string(),\n  children: nullUnion([AddressStruct, ImageStruct, TextStruct, ValueStruct]),\n  variant: optional(\n    nullUnion([literal('default'), literal('warning'), literal('critical')]),\n  ),\n  tooltip: optional(string()),\n});\n\n/**\n * A struct for the {@link SpinnerElement} type.\n */\nexport const SpinnerStruct: Describe<SpinnerElement> = element('Spinner');\n\n/**\n * A subset of JSX elements that are allowed as children of the Box component.\n * This set includes all components, except components that need to be nested in\n * another component (e.g., Field must be contained in a Form).\n */\nexport const BoxChildStruct = typedUnion([\n  AddressStruct,\n  BoldStruct,\n  BoxStruct,\n  ButtonStruct,\n  CopyableStruct,\n  DividerStruct,\n  DropdownStruct,\n  FileInputStruct,\n  FormStruct,\n  HeadingStruct,\n  InputStruct,\n  ImageStruct,\n  ItalicStruct,\n  LinkStruct,\n  RowStruct,\n  SpinnerStruct,\n  TextStruct,\n  TooltipStruct,\n  CheckboxStruct,\n  CardStruct,\n]);\n\n/**\n * For now, the allowed JSX elements at the root are the same as the allowed\n * children of the Box component.\n */\nexport const RootJSXElementStruct = nullUnion([\n  BoxChildStruct,\n  ContainerStruct,\n]);\n\n/**\n * A struct for the {@link JSXElement} type.\n */\nexport const JSXElementStruct: Describe<JSXElement> = typedUnion([\n  ButtonStruct,\n  InputStruct,\n  FileInputStruct,\n  FieldStruct,\n  FormStruct,\n  BoldStruct,\n  ItalicStruct,\n  AddressStruct,\n  BoxStruct,\n  CopyableStruct,\n  DividerStruct,\n  HeadingStruct,\n  ImageStruct,\n  LinkStruct,\n  RowStruct,\n  SpinnerStruct,\n  TextStruct,\n  DropdownStruct,\n  OptionStruct,\n  ValueStruct,\n  TooltipStruct,\n  CheckboxStruct,\n  FooterStruct,\n  ContainerStruct,\n  CardStruct,\n]);\n\n/**\n * Check if a value is a JSX element.\n *\n * @param value - The value to check.\n * @returns True if the value is a JSX element, false otherwise.\n */\nexport function isJSXElement(value: unknown): value is JSXElement {\n  return is(value, JSXElementStruct);\n}\n\n/**\n * Check if a value is a JSX element, without validating all of its contents.\n * This is useful when you want to validate the structure of a value, but not\n * all the children.\n *\n * This should only be used when you are sure that the value is safe to use,\n * i.e., after using {@link isJSXElement}.\n *\n * @param value - The value to check.\n * @returns True if the value is a JSX element, false otherwise.\n */\nexport function isJSXElementUnsafe(value: unknown): value is JSXElement {\n  return (\n    isPlainObject(value) &&\n    hasProperty(value, 'type') &&\n    hasProperty(value, 'props') &&\n    hasProperty(value, 'key')\n  );\n}\n\n/**\n * Assert that a value is a JSX element.\n *\n * @param value - The value to check.\n * @throws If the value is not a JSX element.\n */\nexport function assertJSXElement(value: unknown): asserts value is JSXElement {\n  // TODO: We should use the error parsing utils from `snaps-utils` to improve\n  // the error messages. It currently includes colours and potentially other\n  // formatting that we might not want to include in the SDK.\n  if (!isJSXElement(value)) {\n    throw new Error(\n      `Expected a JSX element, but received ${JSON.stringify(\n        value,\n      )}. Please refer to the documentation for the supported JSX elements and their props.`,\n    );\n  }\n}\n"],"mappings":"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","names":["error","hasProperty","assert","assign","literal","object","isPlainObject","node","string","NodeType","assign","object","literal","assign","literal","object","string","assign","object","literal","string","assign","literal","object","assign","object","literal","assign","literal","object","string","assign","object","literal","string","assign","literal","object","assign","object","literal","array","assign","literal","object","assign","literal","object","optional","string","union","ButtonVariant","ButtonType","assign","object","literal","string","optional","union","assign","literal","object","string","union","assign","literal","object","optional","string","union","InputType","assign","object","literal","optional","string","union","union","assign","object","literal","string","assign","literal","object","string","optional","union","assign","boolean","literal","object","optional","string","assign","object","literal","string","optional","boolean","RowVariant","union","assign","object","literal","optional","string","assign","literal","object","assign","object","literal","assign","object","array","literal","is","assertStruct","is","assertStruct","SeverityLevel","assign","literal","object","optional","string","union","boolean","UserInputEventType","DialogType","AuxiliaryFileEncoding","ManageStateOperation","NotificationType","boolean","nullable","record","string","union","JsonStruct","is","boolean","optional","array","lazy","nullable","number","object","record","string","hasProperty","HexChecksumAddressStruct","isPlainObject","string","number","object","record","nullable","array","lazy","boolean","ButtonStruct","optional","InputStruct","FormStruct","AddressStruct","HexChecksumAddressStruct","CopyableStruct","DividerStruct","HeadingStruct","ImageStruct","TextStruct","RowStruct","SpinnerStruct","union","string","boolean","record","nullable","JsonStruct"]}