{"version":3,"file":"cip3.cjs","sourceRoot":"","sources":["../../src/derivers/cip3.ts"],"names":[],"mappings":"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","sourcesContent":["import { assert, bytesToHex, concatBytes, hexToBytes } from '@metamask/utils';\n\nimport type { DeriveChildKeyArgs } from '.';\nimport { BIP_32_HARDENED_OFFSET } from '../constants';\nimport { type Curve, mod } from '../curves';\nimport { SLIP10Node } from '../SLIP10Node';\nimport { numberToUint32 } from '../utils';\nimport { generateEntropy, getValidatedPath, validateNode } from './shared';\n\n/**\n * CIP-3 https://github.com/cardano-foundation/CIPs/blob/09d7d8ee1bd64f7e6b20b5a6cae088039dce00cb/CIP-0003/CIP-0003.md.\n *\n * CIP-3 defines standards for deriving keys on Cardano.\n *\n * Key attributes.\n * - Root/Master key is derived from entropy, not seed. For this implementation we work with Icarus standard as it is the most widely used.\n * - See https://github.com/cardano-foundation/CIPs/blob/09d7d8ee1bd64f7e6b20b5a6cae088039dce00cb/CIP-0003/Icarus.md.\n *\n * - HD node consists of a 64 byte private key, 32 byte public key and 32 byte chain code.\n * - See https://github.com/cardano-foundation/CIPs/blob/09d7d8ee1bd64f7e6b20b5a6cae088039dce00cb/CIP-0003/CIP-0003.md#master-key-generation.\n *\n * - For derivation of BIP32 HD nodes, it uses modified version called BIP32-Ed25519.\n * - See https://input-output-hk.github.io/adrestia/static/Ed25519_BIP.pdf.\n */\n\n/**\n * Reverses the order of bytes in a Uint8Array.\n *\n * Native BigInt uses big-endian. Since cip3(bip32Edd25519) uses little-endian.\n * We need to reverse the bytes and have separate functions for bigIntToBytes and bytesToBigInt.\n * .slice() is used just to make a copy of the array.\n *\n * @param bytes - The input Uint8Array.\n * @returns A new Uint8Array with the bytes in reversed order.\n */\nexport const toReversed = (bytes: Uint8Array) => bytes.slice().reverse();\n\n/**\n * Converts an array of bytes to a BigInt.\n *\n * @param bytes - The array of bytes to convert.\n * @returns The BigInt representation of the bytes.\n */\nexport const bytesToBigInt = (bytes: Uint8Array) => {\n  const reversed = toReversed(bytes);\n  const bytesInHex = bytesToHex(reversed);\n  return BigInt(bytesInHex);\n};\n\n/**\n * Converts a BigInt to a byte array.\n *\n * @param bigInt - The BigInt to convert.\n * @returns The byte array representation of the BigInt.\n */\nexport const bigIntToBytes = (bigInt: bigint) => {\n  const hexadecimal = bigInt.toString(16);\n  return toReversed(hexToBytes(hexadecimal));\n};\n\n/**\n * Pads end of the given bytes array with zeros to a length of 32 bytes.\n *\n * @param bytes - The bytes array to pad.\n * @returns The padded bytes array.\n */\nexport const padEnd32Bytes = (bytes: Uint8Array) => {\n  return concatBytes([\n    bytes,\n    new Uint8Array(Math.max(32 - bytes.length, 0)).fill(0),\n  ]);\n};\n\n/**\n * Truncates to first 28 bytes and multiplies by 8.\n *\n * @param bytes - Little-Endian big number in bytes.\n * @returns PadEnd32Bytes(left[0, 28] * 8)).\n */\nexport const trunc28Mul8 = (bytes: Uint8Array): Uint8Array => {\n  const truncLeftMul8 = bytesToBigInt(bytes.slice(0, 28)) * BigInt(8);\n  return padEnd32Bytes(bigIntToBytes(truncLeftMul8));\n};\n\n/**\n * Does module 2^256.\n *\n * @param bytes - Little-Endian big number in bytes.\n * @returns PadEnd32Bytes(mod(bytes, 2^256))).\n */\nexport const mod2Pow256 = (bytes: Uint8Array): Uint8Array => {\n  return padEnd32Bytes(\n    bigIntToBytes(mod(bytesToBigInt(bytes), BigInt(2) ** BigInt(256))),\n  );\n};\n\n/**\n * Adds the left to the right.\n *\n * @param left - Left hand side Little-Endian big number.\n * @param right - Right hand side Little-Endian big number.\n * @returns PadEnd32Bytes(left + right).\n */\nexport const add = (left: Uint8Array, right: Uint8Array): Uint8Array => {\n  const added = bytesToBigInt(left) + bytesToBigInt(right);\n  return padEnd32Bytes(bigIntToBytes(added)).slice(0, 32);\n};\n\n/**\n * Concat tag, key and childIndex.\n *\n * @param tag - Key specific tag.\n * @param key - Key.\n * @param childIndex - Child index.\n * @returns PadEnd32Bytes(left + right).\n */\nexport const getKeyExtension = (\n  tag: number,\n  key: Uint8Array,\n  childIndex: number,\n) => {\n  return concatBytes([\n    new Uint8Array([tag]),\n    key,\n    numberToUint32(childIndex, true),\n  ]);\n};\n\nexport type Cip3SupportedCurve = Extract<Curve, { name: 'ed25519Bip32' }>;\n\ntype DeriveKeyBaseArgs = { childIndex: number };\n\ntype DeriveWithPrivateArgs = DeriveKeyBaseArgs & {\n  parentNode: {\n    privateKeyBytes: Uint8Array;\n    chainCodeBytes: Uint8Array;\n    publicKeyBytes: Uint8Array;\n  };\n  isHardened: boolean;\n};\n\nconst Z_TAGS = {\n  normal: 2,\n  hardened: 0,\n};\n\n/**\n * Derives a private child key.\n *\n * Following \"Section V. BIP32-ED25519: SPECIFICATION, C.1,2\" in https://input-output-hk.github.io/adrestia/static/Ed25519_BIP.pdf.\n *\n * @param param1 - The parameters for deriving a child key.\n * @param param1.parentNode - The parent node containing private key, chain code, and public key.\n * @param param1.childIndex - The index of the child key.\n * @param param1.isHardened - Indicates if the child key is hardened.\n * @returns The derived child key.\n */\nexport const derivePrivateKey = async ({\n  parentNode,\n  childIndex,\n  isHardened,\n}: DeriveWithPrivateArgs) => {\n  // extension = i >= 2^31 ? (0x00||kp||i) : (0x02||Ap||i)\n  const extension = isHardened\n    ? getKeyExtension(\n        Z_TAGS.hardened,\n        parentNode.privateKeyBytes,\n        childIndex + BIP_32_HARDENED_OFFSET,\n      )\n    : getKeyExtension(Z_TAGS.normal, parentNode.publicKeyBytes, childIndex);\n\n  // entropy = Fcp(extension)\n  const entropy = generateEntropy({\n    chainCode: parentNode.chainCodeBytes,\n    extension,\n  });\n\n  const zl = entropy.subarray(0, 32);\n  const zr = entropy.subarray(32);\n\n  const parentKl = parentNode.privateKeyBytes.subarray(0, 32);\n  const parentKr = parentNode.privateKeyBytes.subarray(32);\n\n  // 8[ZL] + kPL\n  const childKl = add(trunc28Mul8(zl), parentKl);\n  // ZR + kPR\n  const childKr = add(zr, parentKr);\n  return concatBytes([childKl, childKr]);\n};\n\ntype DeriveWithoutPrivateArgs = DeriveKeyBaseArgs & {\n  parentNode: {\n    chainCodeBytes: Uint8Array;\n    publicKeyBytes: Uint8Array;\n  };\n  isHardened: false;\n};\n\nconst CHAIN_CODE_TAGS = {\n  normal: 3,\n  hardened: 1,\n};\n\n/**\n * Derives a child chainCode.\n *\n * Following \"Section V. BIP32-ED25519: SPECIFICATION, C.3\" in https://input-output-hk.github.io/adrestia/static/Ed25519_BIP.pdf.\n *\n * @param param1 - The parameters for deriving a child chainCode.\n * @param param1.parentNode - The parent node containing optionally a private key, chain code, and public key.\n * @param param1.childIndex - The index of the child key.\n * @param param1.isHardened - Indicates if the child key is hardened.\n * @returns The derived child chainCode.\n */\nexport const deriveChainCode = async ({\n  parentNode,\n  childIndex,\n  isHardened,\n}: DeriveWithPrivateArgs | DeriveWithoutPrivateArgs) => {\n  // extension = i >= 2^31 ? (0x01||kp||i) : (0x03||Ap||i)\n  const extension = isHardened\n    ? getKeyExtension(\n        CHAIN_CODE_TAGS.hardened,\n        parentNode.privateKeyBytes,\n        childIndex + BIP_32_HARDENED_OFFSET,\n      )\n    : getKeyExtension(\n        CHAIN_CODE_TAGS.normal,\n        parentNode.publicKeyBytes,\n        childIndex,\n      );\n\n  // entropy = Fcp(extension)\n  const entropy = generateEntropy({\n    chainCode: parentNode.chainCodeBytes,\n    extension,\n  });\n\n  return entropy.subarray(32);\n};\n\nconst PUBLIC_KEY_TAGS = {\n  normal: 2,\n};\n\ntype DerivePublicKeyArgs = DeriveWithoutPrivateArgs & {\n  curve: Cip3SupportedCurve;\n};\n\n/**\n * Derives a public key.\n *\n * Following \"Section V. BIP32-ED25519: SPECIFICATION, D\" in https://input-output-hk.github.io/adrestia/static/Ed25519_BIP.pdf.\n *\n * @param param1 - The parameters for deriving a child public key.\n * @param param1.parentNode - The parent node containing chain code, and public key.\n * @param param1.childIndex - The index of the child key.\n * @param param1.curve - Derivation curve.\n * @returns The derived child public key.\n */\nexport const derivePublicKey = async ({\n  parentNode,\n  childIndex,\n  curve,\n}: DerivePublicKeyArgs) => {\n  // extension = (0x02||Ap||i)\n  const extension = getKeyExtension(\n    PUBLIC_KEY_TAGS.normal,\n    parentNode.publicKeyBytes,\n    childIndex,\n  );\n\n  // entropy = Fcp(extension)\n  const entropy = generateEntropy({\n    chainCode: parentNode.chainCodeBytes,\n    extension,\n  });\n\n  const zl = entropy.slice(0, 32);\n\n  // right = [8ZL] * B\n  const right = await curve.getPublicKey(\n    // [8ZL]\n    trunc28Mul8(zl),\n  );\n\n  // Ai = AP + [8ZL]B,\n  return curve.publicAdd(parentNode.publicKeyBytes, right);\n};\n\ntype Cip3DeriveChildKeyArgs = DeriveChildKeyArgs & {\n  curve: Cip3SupportedCurve;\n};\n\n/**\n * Derive a SLIP-10 child key with a given path from a parent key.\n *\n * @param options - The options for deriving a child key.\n * @returns SLIP10Node.\n */\nexport async function deriveChildKey(\n  options: Cip3DeriveChildKeyArgs,\n): Promise<SLIP10Node> {\n  const { curve, node, path } = options;\n  validateNode(node);\n\n  const { childIndex, isHardened } = getValidatedPath(path, node, curve);\n  if (curve.name !== 'ed25519Bip32' || !node) {\n    throw new Error(\n      'Unsupported curve: Only ed25519Bip32 is supported by CIP3.',\n    );\n  }\n\n  const actualChildIndex =\n    childIndex + (isHardened ? BIP_32_HARDENED_OFFSET : 0);\n\n  const {\n    privateKeyBytes,\n    chainCodeBytes,\n    publicKeyBytes,\n    masterFingerprint,\n    depth,\n    fingerprint: parentFingerprint,\n  } = node;\n\n  if (privateKeyBytes) {\n    const parentNode = {\n      privateKeyBytes,\n      chainCodeBytes,\n      publicKeyBytes,\n    };\n\n    const privateKey = await derivePrivateKey({\n      parentNode,\n      childIndex,\n      isHardened,\n    });\n\n    const chainCode = await deriveChainCode({\n      parentNode,\n      childIndex,\n      isHardened,\n    });\n\n    return SLIP10Node.fromExtendedKey({\n      privateKey: bytesToHex(privateKey),\n      chainCode: bytesToHex(chainCode),\n      masterFingerprint,\n      depth: depth + 1,\n      parentFingerprint,\n      index: actualChildIndex,\n      curve: curve.name,\n    });\n  }\n\n  assert(\n    !isHardened,\n    'Invalid parameters: Cannot derive hardened child keys without a private key.',\n  );\n\n  const parentNode = {\n    chainCodeBytes,\n    publicKeyBytes,\n  };\n\n  const publicKey = await derivePublicKey({\n    parentNode,\n    childIndex,\n    isHardened: false,\n    curve,\n  });\n\n  const chainCode = await deriveChainCode({\n    parentNode,\n    childIndex,\n    isHardened: false,\n  });\n\n  return SLIP10Node.fromExtendedKey({\n    publicKey: bytesToHex(publicKey),\n    chainCode: bytesToHex(chainCode),\n    masterFingerprint,\n    depth: depth + 1,\n    parentFingerprint,\n    index: actualChildIndex,\n    curve: curve.name,\n  });\n}\n"]}