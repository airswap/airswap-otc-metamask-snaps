export declare const curve: Readonly<{
    readonly nBitLength: number;
    readonly nByteLength: number;
    readonly Fp: import("@noble/curves/abstract/modular").IField<bigint>;
    /**
     * Get a byte from a private key at a given index.
     *
     * @param privateKey - The private key.
     * @param index - The index of the byte to get.
     * @returns The byte at the given index.
     * @throws If the private key is too short.
     */
    readonly n: bigint;
    readonly h: bigint;
    readonly hEff?: bigint | undefined;
    readonly Gx: bigint;
    readonly Gy: bigint;
    readonly allowInfinityPoint?: boolean | undefined;
    readonly a: bigint;
    readonly d: bigint;
    readonly hash: import("@noble/curves/abstract/utils").FHash;
    readonly randomBytes: (bytesLength?: number | undefined) => Uint8Array;
    readonly adjustScalarBytes?: ((bytes: Uint8Array) => Uint8Array) | undefined;
    readonly domain?: ((data: Uint8Array, ctx: Uint8Array, phflag: boolean) => Uint8Array) | undefined;
    readonly uvRatio?: ((u: bigint, v: bigint) => {
        isValid: boolean;
        value: bigint;
    }) | undefined;
    readonly prehash?: import("@noble/curves/abstract/utils").FHash | undefined;
    readonly mapToCurve?: ((scalar: bigint[]) => import("@noble/curves/abstract/curve").AffinePoint<bigint>) | undefined;
    readonly p: bigint;
}>;
/**
 * Named after whitepaper: BIP32-Ed25519 Hierarchical Deterministic Keys over a Non-linear Keyspace
 * https://input-output-hk.github.io/adrestia/static/Ed25519_BIP.pdf
 * "vanilla" "ed25519" curve follows SLIP10: https://tezos.stackexchange.com/questions/2837/can-i-use-bip32-hd-key-pairs-to-derive-ed25519-addresses
 * note that that the important difference of the "bip32" version is that it allows unhardened key derivation
 */
export declare const name = "ed25519Bip32";
export declare const secret: Uint8Array;
/**
 * Check if a private key is valid.
 *
 * @param privateKey - The private key to check.
 * @returns Whether the private key is valid.
 */
export declare const isValidPrivateKey: (privateKey: Uint8Array) => boolean;
export declare const deriveUnhardenedKeys = true;
export declare const publicKeyLength = 32;
/**
 * Converts a Uint8Array of bytes to a bigint in little-endian format.
 *
 * @param bytes - The Uint8Array of bytes to convert.
 * @returns The converted bigint value.
 */
export declare const bytesToNumberLE: (bytes: Uint8Array) => bigint;
/**
 * Multiplies the given key with the base point on the Edwards curve.
 * equivalent to https://github.com/jedisct1/libsodium/blob/93a6e79750a31bc0b946bf483b2ba1c77f9e94ce/src/libsodium/crypto_scalarmult/ed25519/ref10/scalarmult_ed25519_ref10.c#L105 .
 * which is used by cardano-js-sdk/crypto https://github.com/input-output-hk/cardano-js-sdk/blob/8a6db2a251cd1c956f52730a0d35de2b7fc67404/packages/crypto/src/Bip32/Bip32PrivateKey.ts#L161 .
 *
 * @param key - The key to multiply with the base point.
 * @returns The resulting point on the Edwards curve.
 */
export declare const multiplyWithBase: (key: Uint8Array) => Uint8Array;
/**
 * Calculates the public key corresponding to a given private key.
 *
 * @param privateKey - The private key.
 * @param _compressed - Optional parameter to indicate if the public key should be compressed.
 * @returns The public key.
 */
export declare const getPublicKey: (privateKey: Uint8Array, _compressed?: boolean) => Promise<Uint8Array>;
/**
 * Adds a tweak to a public key.
 *
 * @param publicKey - The public key.
 * @param tweak - The tweak to add.
 * @returns The resulting public key.
 */
export declare const publicAdd: (publicKey: Uint8Array, tweak: Uint8Array) => Uint8Array;
/**
 * Compresses an Ed25519 public key.
 *
 * @param publicKey - The public key to compress.
 * @returns The compressed public key.
 */
export declare const compressPublicKey: (publicKey: Uint8Array) => Uint8Array;
/**
 * Decompresses a compressed Ed25519Bip32 public key.
 *
 * @param publicKey - The compressed public key.
 * @returns The decompressed public key.
 */
export declare const decompressPublicKey: (publicKey: Uint8Array) => Uint8Array;
export declare const privateKeyLength = 64;
export declare const masterNodeGenerationSpec = "cip3";
export declare const compressedPublicKeyLength = 32;
//# sourceMappingURL=ed25519Bip32.d.mts.map