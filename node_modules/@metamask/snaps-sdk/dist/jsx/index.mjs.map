{"version":3,"sources":["../../src/jsx/component.ts","../../src/jsx/components/form/Button.ts","../../src/jsx/components/form/Checkbox.ts","../../src/jsx/components/form/Dropdown.ts","../../src/jsx/components/form/Option.ts","../../src/jsx/components/form/Field.ts","../../src/jsx/components/form/FileInput.ts","../../src/jsx/components/form/Form.ts","../../src/jsx/components/form/Input.ts","../../src/jsx/components/formatting/Bold.ts","../../src/jsx/components/formatting/Italic.ts","../../src/jsx/components/Address.ts","../../src/jsx/components/Box.ts","../../src/jsx/components/Card.ts","../../src/jsx/components/Copyable.ts","../../src/jsx/components/Divider.ts","../../src/jsx/components/Value.ts","../../src/jsx/components/Heading.ts","../../src/jsx/components/Image.ts","../../src/jsx/components/Link.ts","../../src/jsx/components/Row.ts","../../src/jsx/components/Spinner.ts","../../src/jsx/components/Text.ts","../../src/jsx/components/Tooltip.ts","../../src/jsx/components/Footer.ts","../../src/jsx/components/Container.ts","../../src/jsx/jsx-runtime.ts","../../src/jsx/validation.ts","../../src/internals/structs.ts","../../src/internals/jsx.ts","../../src/internals/svg.ts","../../src/jsx/jsx-dev-runtime.ts"],"sourcesContent":["import type { Json } from '@metamask/utils';\n\n/**\n * A key, which can be a string or a number.\n */\nexport type Key = string | number;\n\n/**\n * A JSON object.\n */\nexport type JsonObject = Record<string, Json>;\n\n/**\n * A generic JSX element.\n *\n * @property type - The type of the element.\n * @property props - The props of the element.\n * @property key - The key of the element.\n */\nexport type GenericSnapElement = {\n  type: string;\n  props: JsonObject;\n  key: Key | null;\n};\n\n/**\n * A JSX element.\n *\n * @property type - The type of the element.\n * @property props - The props of the element.\n * @property key - The key of the element.\n */\nexport type SnapElement<\n  Props extends JsonObject = Record<string, never>,\n  Type extends string = string,\n> = {\n  type: Type;\n  props: Props;\n  key: Key | null;\n};\n\n/**\n * A type that can be a single value or an infinitely nestable array of values.\n *\n * @template Type - The type that can be an array.\n * @example\n * type NestableString = Nestable<string>;\n * const nestableString: NestableString = 'hello';\n * const nestableStringArray: NestableString = ['hello', 'world', ['foo', ['bar']]];\n */\nexport type Nestable<Type> = Type | Nestable<Type>[];\n\n/**\n * A type that can be a single value or an array of values, a boolean, or null.\n *\n * @template Type - The type that can be an array.\n */\nexport type SnapsChildren<Type> = Nestable<Type | boolean | null>;\n\n/**\n * A JSX node, which can be an element, a string, null, or an array of nodes.\n */\nexport type SnapNode = SnapsChildren<GenericSnapElement | string>;\n\n/**\n * A JSX string element, which can be a string or an array of strings, or\n * booleans (for conditional rendering).\n */\nexport type StringElement = SnapsChildren<string>;\n\n/**\n * A JSX component.\n */\nexport type SnapComponent<\n  Props extends JsonObject = Record<string, never>,\n  Type extends string = string,\n> = (props: Props & { key?: Key | null }) => SnapElement<Props, Type>;\n\n/**\n * Remove undefined props from an object.\n *\n * @param props - The object to remove undefined props from.\n * @returns The object without undefined props.\n */\nfunction removeUndefinedProps<Props extends JsonObject>(props: Props): Props {\n  return Object.fromEntries(\n    Object.entries(props).filter(([, value]) => value !== undefined),\n  ) as Props;\n}\n\n/**\n * Create a Snap component from a type. This is a helper function that creates a\n * Snap component function.\n *\n * @param type - The type of the component.\n * @returns A function that creates a Snap element.\n * @see SnapComponent\n */\nexport function createSnapComponent<\n  Props extends JsonObject = Record<string, never>,\n  Type extends string = string,\n>(type: Type): SnapComponent<Props, Type> {\n  return (props: Props & { key?: Key | null }) => {\n    const { key = null, ...rest } = props;\n    return {\n      type,\n      props: removeUndefinedProps(rest as Props),\n      key,\n    };\n  };\n}\n","import type { StringElement } from '../../component';\nimport { createSnapComponent } from '../../component';\n\n// TODO: Add the `onClick` prop to the `ButtonProps` type.\n\n/**\n * The props of the {@link Button} component.\n *\n * @property children - The text to display on the button.\n * @property name - The name of the button. This is used to identify the button\n * in the event handler.\n * @property type - The type of the button, i.e., `'button'` or `'submit'`.\n * Defaults to `'button'`.\n * @property variant - The variant of the button, i.e., `'primary'` or\n * `'destructive'`. Defaults to `'primary'`.\n * @property disabled - Whether the button is disabled. Defaults to `false`.\n */\nexport type ButtonProps = {\n  children: StringElement;\n  name?: string | undefined;\n  type?: 'button' | 'submit' | undefined;\n  variant?: 'primary' | 'destructive' | undefined;\n  disabled?: boolean | undefined;\n};\n\nconst TYPE = 'Button';\n\n/**\n * A button component, which is used to create a clickable button.\n *\n * @param props - The props of the component.\n * @param props.children - The text to display on the button. This should be a\n * string or an array of strings.\n * @returns A button element.\n * @example\n * <Button name=\"my-button\">Click me</Button>\n */\nexport const Button = createSnapComponent<ButtonProps, typeof TYPE>(TYPE);\n\n/**\n * A button element.\n *\n * @see Button\n */\nexport type ButtonElement = ReturnType<typeof Button>;\n","import { createSnapComponent } from '../../component';\n\n/**\n * The props of the {@link Checkbox} component.\n *\n * @property name - The name of the checkbox. This is used to identify the\n * state in the form data.\n * @property checked - Whether the checkbox is checked or not.\n * @property label - An optional label for the checkbox.\n * @property variant - An optional variant for the checkbox.\n */\nexport type CheckboxProps = {\n  name: string;\n  checked?: boolean | undefined;\n  label?: string | undefined;\n  variant?: 'default' | 'toggle' | undefined;\n};\n\nconst TYPE = 'Checkbox';\n\n/**\n * A checkbox component, which is used to create a checkbox.\n *\n * @param props - The props of the component.\n * @param props.name - The name of the checkbox. This is used to identify the\n * state in the form data.\n * @param props.checked - Whether the checkbox is checked or not.\n * @param props.label - An optional label for the checkbox.\n * @param props.variant - An optional variant for the checkbox.\n * @returns A checkbox element.\n * @example\n * <Checkbox name=\"accept-terms\" />\n */\nexport const Checkbox = createSnapComponent<CheckboxProps, typeof TYPE>(TYPE);\n\n/**\n * A checkbox element.\n *\n * @see Checkbox\n */\nexport type CheckboxElement = ReturnType<typeof Checkbox>;\n","import type { SnapsChildren } from '../../component';\nimport { createSnapComponent } from '../../component';\nimport type { OptionElement } from './Option';\n\n/**\n * The props of the {@link Dropdown} component.\n *\n * @property name - The name of the dropdown. This is used to identify the\n * state in the form data.\n * @property value - The selected value of the dropdown.\n * @property children - The children of the dropdown.\n */\nexport type DropdownProps = {\n  name: string;\n  value?: string | undefined;\n  children: SnapsChildren<OptionElement>;\n};\n\nconst TYPE = 'Dropdown';\n\n/**\n * A dropdown component, which is used to create a dropdown.\n *\n * @param props - The props of the component.\n * @param props.name - The name of the dropdown field. This is used to identify the\n * state in the form data.\n * @param props.value - The selected value of the dropdown.\n * @param props.children - The children of the dropdown.\n * @returns A dropdown element.\n * @example\n * <Dropdown name=\"dropdown\">\n *  <Option value=\"option1\">Option 1</Option>\n *  <Option value=\"option2\">Option 2</Option>\n *  <Option value=\"option3\">Option 3</Option>\n * </Dropdown>\n */\nexport const Dropdown = createSnapComponent<DropdownProps, typeof TYPE>(TYPE);\n\n/**\n * A dropdown element.\n *\n * @see Dropdown\n */\nexport type DropdownElement = ReturnType<typeof Dropdown>;\n","import { createSnapComponent } from '../../component';\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport { Dropdown } from './Dropdown';\n\n/**\n * The props of the {@link Option} component.\n *\n * @property value - The value of the dropdown option. This is used to populate the\n * state in the form data.\n * @property children - The text to display.\n */\ntype OptionProps = {\n  value: string;\n  children: string;\n};\n\nconst TYPE = 'Option';\n\n/**\n * A dropdown option component, which is used to create a dropdown option. This component\n * can only be used as a child of the {@link Dropdown} component.\n *\n * @param props - The props of the component.\n * @param props.value - The value of the dropdown option. This is used to populate the\n * state in the form data.\n * @param props.children - The text to display.\n * @returns A dropdown option element.\n * @example\n * <Dropdown name=\"dropdown\">\n *  <Option value=\"option1\">Option 1</Option>\n *  <Option value=\"option2\">Option 2</Option>\n *  <Option value=\"option3\">Option 3</Option>\n * </Dropdown>\n */\nexport const Option = createSnapComponent<OptionProps, typeof TYPE>(TYPE);\n\n/**\n * A dropdown option element.\n *\n * @see Option\n */\nexport type OptionElement = ReturnType<typeof Option>;\n","import { createSnapComponent } from '../../component';\nimport type { ButtonElement } from './Button';\nimport type { CheckboxElement } from './Checkbox';\nimport type { DropdownElement } from './Dropdown';\nimport type { FileInputElement } from './FileInput';\nimport type { InputElement } from './Input';\n\n/**\n * The props of the {@link Field} component.\n *\n * @property label - The label of the field.\n * @property error - The error message of the field.\n * @property children - The input field and the submit button.\n */\nexport type FieldProps = {\n  label?: string | undefined;\n  error?: string | undefined;\n  children:\n    | [InputElement, ButtonElement]\n    | DropdownElement\n    | FileInputElement\n    | InputElement\n    | CheckboxElement;\n};\n\nconst TYPE = 'Field';\n\n/**\n * A field component, which is used to create a form field. This component can\n * only be used as a child of the {@link Form} component.\n *\n * @param props - The props of the component.\n * @param props.label - The label of the field.\n * @param props.error - The error message of the field.\n * @param props.children - The input field and the submit button.\n * @returns A field element.\n * @example\n * <Field label=\"Username\">\n *   <Input name=\"username\" type=\"text\" />\n *   <Button type=\"submit\">Submit</Button>\n * </Field>\n * @example\n * <Field label=\"Upload file\">\n *   <FileInput name=\"file\" accept={['image/*']} multiple />\n * </Field>\n */\nexport const Field = createSnapComponent<FieldProps, typeof TYPE>(TYPE);\n\n/**\n * A field element.\n *\n * @see Field\n */\nexport type FieldElement = ReturnType<typeof Field>;\n","import { createSnapComponent } from '../../component';\n\n/**\n * The props of the {@link FileInput} component.\n *\n * @property name - The name of the file input field. This is used to identify\n * the file input field in the form data.\n * @property label - The label of the file input field.\n * @property accept - The file types that the file input field accepts. If not\n * specified, the file input field accepts all file types.\n * @property compact - Whether the file input field is compact. Default is\n * `false`.\n */\nexport type FileInputProps = {\n  name: string;\n  accept?: string[] | undefined;\n  compact?: boolean | undefined;\n};\n\nconst TYPE = 'FileInput';\n\n/**\n * A file input component, which is used to create a file input field. This\n * component can only be used as a child of the {@link Field} component.\n *\n * The total size of the files that can be uploaded may not exceed 64 MB.\n *\n * @param props - The props of the component.\n * @param props.name - The name of the file input field. This is used to\n * identify the file input field in the form data.\n * @param props.accept - The file types that the file input field accepts. If\n * not specified, the file input field accepts all file types. For examples of\n * valid values, see the [MDN documentation](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/accept).\n * @param props.compact - Whether the file input field is compact. Default is\n * `false`.\n * @returns A file input element.\n * @example\n * <FileInput name=\"file\" accept={['image/*']} />\n * @example\n * <FileInput name=\"file\" compact />\n * @example\n * <Field label=\"Upload file\">\n *   <FileInput name=\"file\" />\n * </Field>\n */\nexport const FileInput = createSnapComponent<FileInputProps, typeof TYPE>(TYPE);\n\n/**\n * A file input element.\n *\n * @see FileInput\n */\nexport type FileInputElement = ReturnType<typeof FileInput>;\n","import type { GenericSnapElement, SnapsChildren } from '../../component';\nimport { createSnapComponent } from '../../component';\n\n// TODO: Add `onSubmit` prop to the `FormProps` type.\n\n/**\n * The props of the {@link Form} component.\n *\n * @property children - The children of the form.\n * @property name - The name of the form. This is used to identify the form in\n * the event handler.\n */\nexport type FormProps = {\n  children: SnapsChildren<GenericSnapElement>;\n  name: string;\n};\n\nconst TYPE = 'Form';\n\n/**\n * A form component, which is used to create a form.\n *\n * @param props - The props of the component.\n * @param props.children - The form fields. This should be a single field or an\n * array of fields.\n * @param props.name - The name of the form. This is used to identify the form\n * in the event handler.\n * @returns A form element.\n * @example\n * <Form name=\"my-form\">\n *   <Field label=\"Username\">\n *     <Input name=\"username\" type=\"text\" />\n *   </Field>\n *   <Button type=\"submit\">Submit</Button>\n * </Form>\n */\nexport const Form = createSnapComponent<FormProps, typeof TYPE>(TYPE);\n\n/**\n * A form element.\n *\n * @see Form\n */\nexport type FormElement = ReturnType<typeof Form>;\n","import { createSnapComponent } from '../../component';\n\n// TODO: Add the `onChange` prop to the `InputProps` type.\n\n/**\n * The props of the {@link Input} component.\n *\n * @property name - The name of the input field. This is used to identify the\n * input field in the form data.\n * @property type - The type of the input field. Defaults to `text`.\n * @property value - The value of the input field.\n * @property placeholder - The placeholder text of the input field.\n */\nexport type InputProps = {\n  name: string;\n  type?: 'text' | 'password' | 'number' | undefined;\n  value?: string | undefined;\n  placeholder?: string | undefined;\n};\n\nconst TYPE = 'Input';\n\n/**\n * An input component, which is used to create an input field.\n *\n * @param props - The props of the component.\n * @param props.name - The name of the input field. This is used to identify the\n * input field in the form data.\n * @param props.type - The type of the input field.\n * @param props.value - The value of the input field.\n * @param props.placeholder - The placeholder text of the input field.\n * @returns An input element.\n * @example\n * <Input name=\"username\" type=\"text\" />\n */\nexport const Input = createSnapComponent<InputProps, typeof TYPE>(TYPE);\n\n/**\n * An input element.\n *\n * @see Input\n */\nexport type InputElement = ReturnType<typeof Input>;\n","import type { JsonObject, SnapElement, SnapsChildren } from '../../component';\nimport { createSnapComponent } from '../../component';\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport { Text } from '../Text';\n\n/**\n * The children of the {@link Bold} component.\n */\nexport type BoldChildren = SnapsChildren<\n  | string\n  // We have to specify the type here to avoid a circular reference.\n  | SnapElement<JsonObject, 'Italic'>\n>;\n\n/**\n * The props of the {@link Bold} component.\n *\n * @property children - The text to display in bold.\n */\nexport type BoldProps = {\n  children: BoldChildren;\n};\n\nconst TYPE = 'Bold';\n\n/**\n * A bold component, which is used to display text in bold. This component can\n * only be used as a child of the {@link Text} component.\n *\n * @param props - The props of the component.\n * @param props.children - The text to display in bold.\n * @returns A bold element.\n * @example\n * <Text>\n *   Hello <Bold>world</Bold>!\n * </Text>\n */\nexport const Bold = createSnapComponent<BoldProps, typeof TYPE>(TYPE);\n\n/**\n * A bold element.\n *\n * @see Bold\n */\nexport type BoldElement = ReturnType<typeof Bold>;\n","import type { JsonObject, SnapElement, SnapsChildren } from '../../component';\nimport { createSnapComponent } from '../../component';\n\n/**\n * The children of the {@link Italic} component.\n */\nexport type ItalicChildren = SnapsChildren<\n  | string\n  // We have to specify the type here to avoid a circular reference.\n  | SnapElement<JsonObject, 'Bold'>\n>;\n\n/**\n * The props of the {@link Italic} component.\n *\n * @property children - The text to display in italic. This should be a string\n * or an array of strings.\n */\nexport type ItalicProps = {\n  children: ItalicChildren;\n};\n\nconst TYPE = 'Italic';\n\n/**\n * An italic component, which is used to display text in italic. This componen\n * can only be used as a child of the {@link Text} component.\n *\n * @param props - The props of the component.\n * @param props.children - The text to display in italic. This should be a\n * string or an array of strings.\n * @returns An italic element.\n * @example\n * <Text>\n *   Hello <Italic>world</Italic>!\n * </Text>\n */\nexport const Italic = createSnapComponent<ItalicProps, typeof TYPE>(TYPE);\n\n/**\n * An italic element.\n *\n * @see Italic\n */\nexport type ItalicElement = ReturnType<typeof Italic>;\n","import { createSnapComponent } from '../component';\n\n/**\n * The props of the {@link Address} component.\n *\n * @property address - The (Ethereum) address to display. This should be a\n * valid Ethereum address, starting with `0x`.\n */\nexport type AddressProps = {\n  address: `0x${string}`;\n};\n\nconst TYPE = 'Address';\n\n/**\n * An address component, which is used to display an Ethereum address.\n *\n * This component does not accept any children.\n *\n * @param props - The props of the component.\n * @param props.address - The (Ethereum) address to display. This should be a\n * valid Ethereum address, starting with `0x`.\n * @returns An address element.\n * @example\n * <Address address=\"0x1234567890123456789012345678901234567890\" />\n */\nexport const Address = createSnapComponent<AddressProps, typeof TYPE>(TYPE);\n\n/**\n * An address element.\n *\n * @see Address\n */\nexport type AddressElement = ReturnType<typeof Address>;\n","import type { GenericSnapElement, SnapsChildren } from '../component';\nimport { createSnapComponent } from '../component';\n\n/**\n * The props of the {@link Box} component.\n *\n * @property children - The children of the box.\n * @property direction - The direction to stack the components within the box. Defaults to `vertical`.\n * @property alignment - The alignment mode to use within the box. Defaults to `start`.\n */\nexport type BoxProps = {\n  // We can't use `JSXElement` because it causes a circular reference.\n  children: SnapsChildren<GenericSnapElement>;\n  direction?: 'vertical' | 'horizontal' | undefined;\n  alignment?:\n    | 'start'\n    | 'center'\n    | 'end'\n    | 'space-between'\n    | 'space-around'\n    | undefined;\n};\n\nconst TYPE = 'Box';\n\n/**\n * A box component, which is used to group multiple components together.\n *\n * @param props - The props of the component.\n * @param props.children - The children of the box.\n * @returns A box element.\n * @example\n * <Box>\n *   <Text>Hello world!</Text>\n * </Box>\n */\nexport const Box = createSnapComponent<BoxProps, typeof TYPE>(TYPE);\n\n/**\n * A box element.\n *\n * @see Box\n */\nexport type BoxElement = ReturnType<typeof Box>;\n","import { createSnapComponent } from '../component';\n\n/**\n * The props of the {@link Card} component.\n *\n * @property image - The image to show as part of the card, must be an SVG string.\n * @property title - The title.\n * @property description - The description, shown below the title.\n * @property value - The value, shown on the right side.\n * @property extra - An additional optional value shown below the value.\n */\nexport type CardProps = {\n  image?: string | undefined;\n  title: string;\n  description?: string | undefined;\n  value: string;\n  extra?: string | undefined;\n};\n\nconst TYPE = 'Card';\n\n/**\n * A card component which can be used to display values within a card structure.\n *\n * @param props - The props of the component.\n * @param props.image - The image to show as part of the card, must be an SVG string.\n * @param props.title - The title.\n * @param props.description - The description, shown below the title.\n * @param props.value - The value, shown on the right side.\n * @param props.extra - An additional optional value shown below the value.\n * @returns A card element.\n * @example\n * <Card image=\"<svg />\" title=\"Title\" description=\"Description\" value=\"$1200\" extra=\"0.12 ETH\" />\n */\nexport const Card = createSnapComponent<CardProps, typeof TYPE>(TYPE);\n\n/**\n * A card element.\n *\n * @see Card\n */\nexport type CardElement = ReturnType<typeof Card>;\n","import { createSnapComponent } from '../component';\n\n/**\n * The props of the {@link Copyable} component.\n *\n * @property value - The value to copy when the user clicks on the copyable\n * element.\n * @property sensitive - Whether the value is sensitive. If `true`, the value\n * will be hidden when the user is not interacting with the copyable element.\n */\nexport type CopyableProps = {\n  value: string;\n  sensitive?: boolean | undefined;\n};\n\nconst TYPE = 'Copyable';\n\n/**\n * A copyable component, which is used to display text that can be copied by the\n * user.\n *\n * @param props - The props of the component.\n * @param props.value - The value to copy when the user clicks on the copyable\n * element.\n * @param props.sensitive - Whether the value is sensitive. If `true`, the value\n * will be hidden when the user is not interacting with the copyable element.\n * @example\n * <Copyable value=\"0x1234567890123456789012345678901234567890\" />\n * <Copyable value=\"0x1234567890123456789012345678901234567890\" sensitive />\n */\nexport const Copyable = createSnapComponent<CopyableProps, typeof TYPE>(TYPE);\n\n/**\n * A copyable element.\n *\n * @see Copyable\n */\nexport type CopyableElement = ReturnType<typeof Copyable>;\n","import { createSnapComponent } from '../component';\n\nconst TYPE = 'Divider';\n\n/**\n * A divider component, which is used to create a horizontal line between\n * elements.\n *\n * This component does not have any props.\n *\n * @returns A divider element.\n * @example\n * <Divider />\n */\nexport const Divider = createSnapComponent(TYPE);\n\n/**\n * A divider element.\n *\n * @see Divider\n */\nexport type DividerElement = ReturnType<typeof Divider>;\n","import { createSnapComponent } from '../component';\n\n/**\n * The props of the {@link Value} component.\n *\n * @property value - The value shown on the right side.\n * @property extra - The extra text shown on the left side.\n */\nexport type ValueProps = {\n  value: string;\n  extra: string;\n};\n\nconst TYPE = 'Value';\n\n/**\n * A value component, which can be used to display two different text values side by side.\n *\n * This component can only be used as a child of the {@link Row} component.\n *\n * This component does not accept any children.\n *\n * @param props - The props of the component.\n * @param props.value - The value shown on the right side.\n * @param props.extra - The extra text shown on the left side.\n * @returns A value element.\n * @example\n * <Value value=\"0.05 ETH\" extra=\"$200\" />\n */\nexport const Value = createSnapComponent<ValueProps, typeof TYPE>(TYPE);\n\n/**\n * A value element.\n *\n * @see Value\n */\nexport type ValueElement = ReturnType<typeof Value>;\n","import type { StringElement } from '../component';\nimport { createSnapComponent } from '../component';\n\n/**\n * The props of the {@link Heading} component.\n *\n * @property children - The text to display in the heading.\n */\ntype HeadingProps = {\n  children: StringElement;\n};\n\nconst TYPE = 'Heading';\n\n/**\n * A heading component, which is used to display heading text.\n *\n * @param props - The props of the component.\n * @param props.children - The text to display in the heading.\n * @returns A heading element.\n * @example\n * <Heading>Hello world!</Heading>\n */\nexport const Heading = createSnapComponent<HeadingProps, typeof TYPE>(TYPE);\n\n/**\n * A heading element.\n *\n * @see Heading\n */\nexport type HeadingElement = ReturnType<typeof Heading>;\n","import { createSnapComponent } from '../component';\n\n/**\n * The props of the {@link Image} component.\n *\n * @property src - The SVG image to display. This should be an SVG string, and\n * other formats such as PNG and JPEG are not supported directly. You can use\n * the `data:` URL scheme to embed images inside the SVG.\n * @property alt - The alternative text of the image, which describes the image\n * for users who cannot see it.\n */\ntype ImageProps = {\n  src: string;\n  alt?: string | undefined;\n};\n\nconst TYPE = 'Image';\n\n/**\n * An image component, which is used to display an image.\n *\n * This component does not accept any children.\n *\n * @param props - The props of the component.\n * @param props.src - The URL of the image to display. This should be an SVG\n * string, and other formats such as PNG and JPEG are not supported directly.\n * You can use the `data:` URL scheme to embed images inside the SVG.\n * @param props.alt - The alternative text of the image, which describes the\n * image for users who cannot see it.\n * @returns An image element.\n * @example\n * <Image src=\"<svg>...</svg>\" alt=\"An example image\" />\n */\nexport const Image = createSnapComponent<ImageProps, typeof TYPE>(TYPE);\n\n/**\n * An image element.\n *\n * @see Image\n */\nexport type ImageElement = ReturnType<typeof Image>;\n","import type { SnapsChildren } from '../component';\nimport { createSnapComponent } from '../component';\nimport type { StandardFormattingElement } from './formatting';\n\n/**\n * The children of the {@link Link} component.\n */\nexport type LinkChildren = SnapsChildren<string | StandardFormattingElement>;\n\n/**\n * The props of the {@link Link} component.\n *\n * @property children - The text to display in the link.\n * @property href - The URL to link to. This must be an `https` or `mailto` URL.\n * `http` is not allowed.\n */\nexport type LinkProps = {\n  children: LinkChildren;\n  href: string;\n};\n\nconst TYPE = 'Link';\n\n/**\n * A link component, which is used to display a hyperlink.\n *\n * @param props - The props of the component.\n * @param props.children - The text to display in the link.\n * @param props.href - The URL to link to. This must be an `https` or `mailto`\n * URL. `http` is not allowed.\n * @returns A link element.\n * @example\n * <Link href=\"https://example.com\">Click here</Link>\n */\nexport const Link = createSnapComponent<LinkProps, typeof TYPE>(TYPE);\n\n/**\n * A link element.\n *\n * @see Link\n */\nexport type LinkElement = ReturnType<typeof Link>;\n","import { createSnapComponent } from '../component';\nimport type { AddressElement } from './Address';\nimport type { ImageElement } from './Image';\nimport type { TextElement } from './Text';\nimport type { ValueElement } from './Value';\n\n/**\n * The children of a {@link Row} component.\n */\nexport type RowChildren =\n  | AddressElement\n  | ImageElement\n  | TextElement\n  | ValueElement;\n\n/**\n * The props of the {@link Row} component.\n *\n * @property label - The label of the row.\n * @property children - The content of the row. This can be an address, an\n * image, or text.\n * @property variant - The variant of the row.\n * @property tooltip - An optional tooltip to show for the row.\n */\nexport type RowProps = {\n  label: string;\n  children: RowChildren;\n  variant?: 'default' | 'warning' | 'critical' | undefined;\n  tooltip?: string | undefined;\n};\n\nconst TYPE = 'Row';\n\n/**\n * A row component, which is used to display a row of information.\n *\n * @param props - The props of the component.\n * @param props.label - The label of the row.\n * @param props.children - The content of the row. This can be an address, an\n * image, or text.\n * @param props.variant - The variant of the row.\n * @param props.tooltip - An optional tooltip to show for the row.\n * @returns A row element.\n * @example\n * <Row label=\"From\" variant=\"warning\" tooltip=\"This address has been deemed dangerous.\">\n *   <Address address=\"0x1234567890123456789012345678901234567890\" />\n * </Row>\n */\nexport const Row = createSnapComponent<RowProps, typeof TYPE>(TYPE);\n\n/**\n * A row element.\n *\n * @see Row\n */\nexport type RowElement = ReturnType<typeof Row>;\n","import { createSnapComponent } from '../component';\n\nconst TYPE = 'Spinner';\n\n/**\n * A spinner component, which is used to display a spinner, indicating that some\n * operation is in progress.\n *\n * This component does not accept any props.\n *\n * @returns A spinner element.\n * @example\n * <Spinner />\n */\nexport const Spinner = createSnapComponent(TYPE);\n\n/**\n * A spinner element.\n *\n * @see Spinner\n */\nexport type SpinnerElement = ReturnType<typeof Spinner>;\n","import type { SnapsChildren } from '../component';\nimport { createSnapComponent } from '../component';\nimport type { StandardFormattingElement } from './formatting';\nimport type { LinkElement } from './Link';\n\n/**\n * The children of the {@link Text} component.\n */\nexport type TextChildren = SnapsChildren<\n  string | StandardFormattingElement | LinkElement\n>;\n\n/**\n * The props of the {@link Text} component.\n *\n * @property children - The text to display.\n */\nexport type TextProps = {\n  children: TextChildren;\n  alignment?: 'start' | 'center' | 'end' | undefined;\n};\n\nconst TYPE = 'Text';\n\n/**\n * A text component, which is used to display text.\n *\n * @param props - The props of the component.\n * @param props.children - The text to display.\n * @returns A text element.\n * @example\n * <Text>\n *   Hello <Bold>world</Bold>!\n * </Text>\n * @example\n * <Text alignment=\"end\">\n *   Hello <Bold>world</Bold>!\n * </Text>\n */\nexport const Text = createSnapComponent<TextProps, typeof TYPE>(TYPE);\n\n/**\n * A text element.\n *\n * @see Text\n */\nexport type TextElement = ReturnType<typeof Text>;\n","import { createSnapComponent } from '../component';\nimport type { StandardFormattingElement } from './formatting';\nimport type { ImageElement } from './Image';\nimport type { LinkElement } from './Link';\nimport type { TextElement } from './Text';\n\nexport type TooltipChildren =\n  | TextElement\n  | StandardFormattingElement\n  | LinkElement\n  | ImageElement\n  | boolean\n  | null;\n\n/**\n * The props of the {@link Tooltip} component.\n *\n * @property children - The children of the box.\n * @property content - The text to display in the tooltip.\n */\nexport type TooltipProps = {\n  children: TooltipChildren;\n  content: TextElement | StandardFormattingElement | LinkElement | string;\n};\n\nconst TYPE = 'Tooltip';\n\n/**\n * A tooltip component, which is used to display text in a tooltip.\n *\n * @param props - The props of the component.\n * @param props.children - The children of the tooltip.\n * @param props.content - The text to display in the tooltip.\n * @returns A tooltip element.\n * @example\n * <Tooltip content=\"Tooltip text\">\n *   <Text>Hello world!</Text>\n * </Tooltip>\n * @example\n * <Tooltip content={<Text>Text with <Bold>formatting</Bold></Text>}>\n *   <Text>Hello world!</Text>\n * </Tooltip>\n */\nexport const Tooltip = createSnapComponent<TooltipProps, typeof TYPE>(TYPE);\n\n/**\n * A tooltip element.\n *\n * @see Tooltip\n */\nexport type TooltipElement = ReturnType<typeof Tooltip>;\n","import { createSnapComponent } from '../component';\nimport type { ButtonElement } from './form';\n\n/**\n * The props of the {@link Footer} component.\n *\n * @property children - The single or multiple buttons in the footer.\n */\nexport type FooterProps = {\n  children: ButtonElement | [ButtonElement, ButtonElement];\n};\n\nconst TYPE = 'Footer';\n\n/**\n * A footer component, which is used to create a footer with buttons.\n *\n * @param props - The props of the component.\n * @param props.children - The single or multiple buttons in the footer.\n * @returns A footer element.\n * @example\n * <Footer>\n *   <Button name=\"cancel\">Cancel</Button>\n *   <Button name=\"confirm\">Confirm</Button>\n * </Footer>\n */\nexport const Footer = createSnapComponent<FooterProps, typeof TYPE>(TYPE);\n\n/**\n * A footer element.\n *\n * @see Footer\n */\nexport type FooterElement = ReturnType<typeof Footer>;\n","import { createSnapComponent } from '../component';\nimport type { BoxElement } from './Box';\nimport type { FooterElement } from './Footer';\n\n/**\n * The props of the {@link Container} component.\n *\n * @property children - The Box and the Footer or the Box element.\n */\nexport type ContainerProps = {\n  children: [BoxElement, FooterElement] | BoxElement;\n};\n\nconst TYPE = 'Container';\n\n/**\n * A container component, which is used to create a container with a box and a footer.\n *\n * @param props - The props of the component.\n * @param props.children - The Box and the Footer or the Box element.\n * @returns A container element.\n * @example\n * <Container>\n *   <Box>\n *     <Text>Hello world!</Text>\n *   </Box>\n *   <Footer>\n *     <Button name=\"cancel\">Cancel</Button>\n *     <Button name=\"confirm\">Confirm</Button>\n *   </Footer>\n * </Container>\n */\nexport const Container = createSnapComponent<ContainerProps, typeof TYPE>(TYPE);\n\n/**\n * A container element.\n *\n * @see Container\n */\nexport type ContainerElement = ReturnType<typeof Container>;\n","import type { JsonObject, Key, SnapComponent } from './component';\n\n/**\n * The JSX runtime for Snaps SDK components. This function is used to render\n * Snap components into a format that can be used by the Snaps.\n *\n * This is the \"production\" version of the runtime, which does not include\n * additional validation, as it is handled by MetaMask. To use this runtime,\n * specify `@metamask/snaps-sdk` as import source for JSX, and use `react-jsx`\n * as the pragma.\n *\n * @param component - The component to render.\n * @param props - The props to pass to the component.\n * @param key - The key of the component.\n * @returns The rendered component.\n * @see https://www.typescriptlang.org/tsconfig/#jsx\n */\nexport function jsx<Props extends JsonObject>(\n  component: SnapComponent<Props>,\n  props: Props,\n  key: Key | null,\n): unknown | null {\n  if (typeof component === 'string') {\n    // If component is a string, it is a built-in HTML element. This is not\n    // supported in Snaps, so we throw an error.\n    throw new Error(\n      `An HTML element (\"${String(\n        component,\n      )}\") was used in a Snap component, which is not supported by Snaps UI. Please use one of the supported Snap components.`,\n    );\n  }\n\n  if (!component) {\n    // If component is undefined, a JSX fragment `<>...</>` was used, which is\n    // not supported in Snaps.\n    throw new Error(\n      'A JSX fragment was used in a Snap component, which is not supported by Snaps UI. Please use one of the supported Snap components.',\n    );\n  }\n\n  return component({ ...props, key });\n}\n\n/**\n * The JSX runtime for Snaps SDK components. This function is used to render\n * Snap components into a format that can be used by the Snaps.\n *\n * The `jsxs` function is used for rendering nested components.\n *\n * This is the \"production\" version of the runtime, which does not include\n * additional validation, as it is handled by MetaMask. To use this runtime,\n * specify `@metamask/snaps-sdk` as import source for JSX, and use `react-jsx`\n * as the pragma.\n *\n * @param component - The component to render.\n * @param props - The props to pass to the component.\n * @param key - The key of the component.\n * @returns The rendered component.\n * @see https://www.typescriptlang.org/tsconfig/#jsx\n */\nexport function jsxs<Props extends JsonObject>(\n  component: SnapComponent<Props>,\n  props: Props,\n  key: Key | null,\n): unknown | null {\n  return jsx(component, props, key);\n}\n","import type {\n  AnyStruct,\n  Infer,\n  InferStructTuple,\n  ObjectSchema,\n  Struct,\n} from '@metamask/superstruct';\nimport {\n  is,\n  boolean,\n  optional,\n  array,\n  lazy,\n  nullable,\n  number,\n  object,\n  record,\n  string,\n  tuple,\n} from '@metamask/superstruct';\nimport {\n  hasProperty,\n  HexChecksumAddressStruct,\n  isPlainObject,\n  JsonStruct,\n} from '@metamask/utils';\n\nimport type { Describe } from '../internals';\nimport { literal, nullUnion, svg, typedUnion } from '../internals';\nimport type { EmptyObject } from '../types';\nimport type {\n  GenericSnapElement,\n  JsonObject,\n  Key,\n  Nestable,\n  SnapElement,\n  SnapsChildren,\n  StringElement,\n} from './component';\nimport type {\n  AddressElement,\n  BoldElement,\n  BoxElement,\n  ButtonElement,\n  CheckboxElement,\n  CardElement,\n  CopyableElement,\n  DividerElement,\n  DropdownElement,\n  OptionElement,\n  FieldElement,\n  FormElement,\n  HeadingElement,\n  ImageElement,\n  InputElement,\n  ItalicElement,\n  JSXElement,\n  LinkElement,\n  RowElement,\n  SpinnerElement,\n  StandardFormattingElement,\n  TextElement,\n  TooltipElement,\n  ValueElement,\n  FileInputElement,\n  ContainerElement,\n  FooterElement,\n} from './components';\n\n/**\n * A struct for the {@link Key} type.\n */\nexport const KeyStruct: Describe<Key> = nullUnion([string(), number()]);\n\n/**\n * A struct for the {@link StringElement} type.\n */\nexport const StringElementStruct: Describe<StringElement> = children([\n  string(),\n]);\n\n/**\n * A struct for the {@link GenericSnapElement} type.\n */\nexport const ElementStruct: Describe<GenericSnapElement> = object({\n  type: string(),\n  props: record(string(), JsonStruct),\n  key: nullable(KeyStruct),\n});\n\n/**\n * A helper function for creating a struct for a {@link Nestable} type.\n *\n * @param struct - The struct for the type to test.\n * @returns The struct for the nestable type.\n */\nfunction nestable<Type, Schema>(\n  struct: Struct<Type, Schema>,\n): Struct<Nestable<Type>, any> {\n  const nestableStruct: Struct<Nestable<Type>> = nullUnion([\n    struct,\n    array(lazy(() => nestableStruct)),\n  ]);\n\n  return nestableStruct;\n}\n\n/**\n * A helper function for creating a struct which allows children of a specific\n * type, as well as `null` and `boolean`.\n *\n * @param structs - The structs to allow as children.\n * @returns The struct for the children.\n */\nfunction children<Head extends AnyStruct, Tail extends AnyStruct[]>(\n  structs: [head: Head, ...tail: Tail],\n): Struct<\n  Nestable<Infer<Head> | InferStructTuple<Tail>[number] | boolean | null>,\n  null\n> {\n  return nestable(nullable(nullUnion([...structs, boolean()])));\n}\n\n/**\n * A helper function for creating a struct for a JSX element.\n *\n * @param name - The name of the element.\n * @param props - The props of the element.\n * @returns The struct for the element.\n */\nfunction element<Name extends string, Props extends ObjectSchema = EmptyObject>(\n  name: Name,\n  props: Props = {} as Props,\n) {\n  return object({\n    type: literal(name) as unknown as Struct<Name, Name>,\n    props: object(props),\n    key: nullable(KeyStruct),\n  });\n}\n\n/**\n * A struct for the {@link ButtonElement} type.\n */\nexport const ButtonStruct: Describe<ButtonElement> = element('Button', {\n  children: StringElementStruct,\n  name: optional(string()),\n  type: optional(nullUnion([literal('button'), literal('submit')])),\n  variant: optional(nullUnion([literal('primary'), literal('destructive')])),\n  disabled: optional(boolean()),\n});\n\n/**\n * A struct for the {@link CheckboxElement} type.\n */\nexport const CheckboxStruct: Describe<CheckboxElement> = element('Checkbox', {\n  name: string(),\n  checked: optional(boolean()),\n  label: optional(string()),\n  variant: optional(nullUnion([literal('default'), literal('toggle')])),\n});\n\n/**\n * A struct for the {@link InputElement} type.\n */\nexport const InputStruct: Describe<InputElement> = element('Input', {\n  name: string(),\n  type: optional(\n    nullUnion([literal('text'), literal('password'), literal('number')]),\n  ),\n  value: optional(string()),\n  placeholder: optional(string()),\n});\n\n/**\n * A struct for the {@link OptionElement} type.\n */\nexport const OptionStruct: Describe<OptionElement> = element('Option', {\n  value: string(),\n  children: string(),\n});\n\n/**\n * A struct for the {@link DropdownElement} type.\n */\nexport const DropdownStruct: Describe<DropdownElement> = element('Dropdown', {\n  name: string(),\n  value: optional(string()),\n  children: children([OptionStruct]),\n});\n\n/**\n * A struct for the {@link FileInputElement} type.\n */\nexport const FileInputStruct: Describe<FileInputElement> = element(\n  'FileInput',\n  {\n    name: string(),\n    accept: nullUnion([optional(array(string()))]),\n    compact: optional(boolean()),\n  },\n);\n\n/**\n * A subset of JSX elements that represent the tuple Button + Input of the Field children.\n */\nconst BUTTON_INPUT = [InputStruct, ButtonStruct] as [\n  typeof InputStruct,\n  typeof ButtonStruct,\n];\n\n/**\n * A subset of JSX elements that are allowed as single children of the Field component.\n */\nconst FIELD_CHILDREN_ARRAY = [\n  InputStruct,\n  DropdownStruct,\n  FileInputStruct,\n  CheckboxStruct,\n] as [\n  typeof InputStruct,\n  typeof DropdownStruct,\n  typeof FileInputStruct,\n  typeof CheckboxStruct,\n];\n\n/**\n * A union of the allowed children of the Field component.\n * This is mainly used in the simulator for validation purposes.\n */\nexport const FieldChildUnionStruct = nullUnion([\n  ...FIELD_CHILDREN_ARRAY,\n  ...BUTTON_INPUT,\n]);\n\n/**\n * A subset of JSX elements that are allowed as children of the Field component.\n */\nconst FieldChildStruct = nullUnion([\n  tuple(BUTTON_INPUT),\n  ...FIELD_CHILDREN_ARRAY,\n]);\n\n/**\n * A struct for the {@link FieldElement} type.\n */\nexport const FieldStruct: Describe<FieldElement> = element('Field', {\n  label: optional(string()),\n  error: optional(string()),\n  children: FieldChildStruct,\n});\n\n/**\n * A subset of JSX elements that are allowed as children of the Form component.\n */\nexport const FormChildStruct = children(\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  [FieldStruct, lazy(() => BoxChildStruct)],\n) as unknown as Struct<SnapsChildren<GenericSnapElement>, null>;\n\n/**\n * A struct for the {@link FormElement} type.\n */\nexport const FormStruct: Describe<FormElement> = element('Form', {\n  children: FormChildStruct,\n  name: string(),\n});\n\n/**\n * A struct for the {@link BoldElement} type.\n */\nexport const BoldStruct: Describe<BoldElement> = element('Bold', {\n  children: children([\n    string(),\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    lazy(() => ItalicStruct) as unknown as Struct<\n      SnapElement<JsonObject, 'Italic'>\n    >,\n  ]),\n});\n\n/**\n * A struct for the {@link ItalicElement} type.\n */\nexport const ItalicStruct: Describe<ItalicElement> = element('Italic', {\n  children: children([\n    string(),\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    lazy(() => BoldStruct) as unknown as Struct<\n      SnapElement<JsonObject, 'Bold'>\n    >,\n  ]),\n});\n\nexport const FormattingStruct: Describe<StandardFormattingElement> = nullUnion([\n  BoldStruct,\n  ItalicStruct,\n]);\n\n/**\n * A struct for the {@link AddressElement} type.\n */\nexport const AddressStruct: Describe<AddressElement> = element('Address', {\n  address: HexChecksumAddressStruct,\n});\n\nexport const BoxChildrenStruct = children(\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  [lazy(() => BoxChildStruct)],\n) as unknown as Struct<SnapsChildren<GenericSnapElement>, null>;\n\n/**\n * A struct for the {@link BoxElement} type.\n */\nexport const BoxStruct: Describe<BoxElement> = element('Box', {\n  children: BoxChildrenStruct,\n  direction: optional(nullUnion([literal('horizontal'), literal('vertical')])),\n  alignment: optional(\n    nullUnion([\n      literal('start'),\n      literal('center'),\n      literal('end'),\n      literal('space-between'),\n      literal('space-around'),\n    ]),\n  ),\n});\n\n/**\n * A subset of JSX elements that are allowed as children of the Footer component.\n * This set should include a single button or a tuple of two buttons.\n */\nexport const FooterChildStruct = nullUnion([\n  tuple([ButtonStruct, ButtonStruct]),\n  ButtonStruct,\n]);\n\n/**\n * A struct for the {@link FooterElement} type.\n */\nexport const FooterStruct: Describe<FooterElement> = element('Footer', {\n  children: FooterChildStruct,\n});\n\n/**\n * A subset of JSX elements that are allowed as children of the Container component.\n * This set should include a single Box or a tuple of a Box and a Footer component.\n */\nexport const ContainerChildStruct = nullUnion([\n  tuple([BoxStruct, FooterStruct]),\n  BoxStruct,\n]);\n\n/**\n * A struct for the {@link ContainerElement} type.\n */\nexport const ContainerStruct: Describe<ContainerElement> = element(\n  'Container',\n  {\n    children: ContainerChildStruct,\n  },\n);\n\n/**\n * A struct for the {@link CopyableElement} type.\n */\nexport const CopyableStruct: Describe<CopyableElement> = element('Copyable', {\n  value: string(),\n  sensitive: optional(boolean()),\n});\n\n/**\n * A struct for the {@link DividerElement} type.\n */\nexport const DividerStruct: Describe<DividerElement> = element('Divider');\n\n/**\n * A struct for the {@link ValueElement} type.\n */\nexport const ValueStruct: Describe<ValueElement> = element('Value', {\n  value: string(),\n  extra: string(),\n});\n\n/**\n * A struct for the {@link CardElement} type.\n */\nexport const CardStruct: Describe<CardElement> = element('Card', {\n  image: optional(string()),\n  title: string(),\n  description: optional(string()),\n  value: string(),\n  extra: optional(string()),\n});\n\n/**\n * A struct for the {@link HeadingElement} type.\n */\nexport const HeadingStruct: Describe<HeadingElement> = element('Heading', {\n  children: StringElementStruct,\n});\n\n/**\n * A struct for the {@link ImageElement} type.\n */\nexport const ImageStruct: Describe<ImageElement> = element('Image', {\n  src: svg(),\n  alt: optional(string()),\n});\n\n/**\n * A struct for the {@link LinkElement} type.\n */\nexport const LinkStruct: Describe<LinkElement> = element('Link', {\n  href: string(),\n  children: children([FormattingStruct, string()]),\n});\n\n/**\n * A struct for the {@link TextElement} type.\n */\nexport const TextStruct: Describe<TextElement> = element('Text', {\n  children: children([string(), BoldStruct, ItalicStruct, LinkStruct]),\n  alignment: optional(\n    nullUnion([literal('start'), literal('center'), literal('end')]),\n  ),\n});\n\n/**\n * A subset of JSX elements that are allowed as children of the Tooltip component.\n * This set should include all text components and the Image.\n */\nexport const TooltipChildStruct = nullUnion([\n  TextStruct,\n  BoldStruct,\n  ItalicStruct,\n  LinkStruct,\n  ImageStruct,\n  boolean(),\n]);\n\n/**\n * A subset of JSX elements that are allowed as content of the Tooltip component.\n * This set should include all text components.\n */\nexport const TooltipContentStruct = nullUnion([\n  TextStruct,\n  BoldStruct,\n  ItalicStruct,\n  LinkStruct,\n  string(),\n]);\n\n/**\n * A struct for the {@link TooltipElement} type.\n */\nexport const TooltipStruct: Describe<TooltipElement> = element('Tooltip', {\n  children: nullable(TooltipChildStruct),\n  content: TooltipContentStruct,\n});\n\n/**\n * A struct for the {@link RowElement} type.\n */\nexport const RowStruct: Describe<RowElement> = element('Row', {\n  label: string(),\n  children: nullUnion([AddressStruct, ImageStruct, TextStruct, ValueStruct]),\n  variant: optional(\n    nullUnion([literal('default'), literal('warning'), literal('critical')]),\n  ),\n  tooltip: optional(string()),\n});\n\n/**\n * A struct for the {@link SpinnerElement} type.\n */\nexport const SpinnerStruct: Describe<SpinnerElement> = element('Spinner');\n\n/**\n * A subset of JSX elements that are allowed as children of the Box component.\n * This set includes all components, except components that need to be nested in\n * another component (e.g., Field must be contained in a Form).\n */\nexport const BoxChildStruct = typedUnion([\n  AddressStruct,\n  BoldStruct,\n  BoxStruct,\n  ButtonStruct,\n  CopyableStruct,\n  DividerStruct,\n  DropdownStruct,\n  FileInputStruct,\n  FormStruct,\n  HeadingStruct,\n  InputStruct,\n  ImageStruct,\n  ItalicStruct,\n  LinkStruct,\n  RowStruct,\n  SpinnerStruct,\n  TextStruct,\n  TooltipStruct,\n  CheckboxStruct,\n  CardStruct,\n]);\n\n/**\n * For now, the allowed JSX elements at the root are the same as the allowed\n * children of the Box component.\n */\nexport const RootJSXElementStruct = nullUnion([\n  BoxChildStruct,\n  ContainerStruct,\n]);\n\n/**\n * A struct for the {@link JSXElement} type.\n */\nexport const JSXElementStruct: Describe<JSXElement> = typedUnion([\n  ButtonStruct,\n  InputStruct,\n  FileInputStruct,\n  FieldStruct,\n  FormStruct,\n  BoldStruct,\n  ItalicStruct,\n  AddressStruct,\n  BoxStruct,\n  CopyableStruct,\n  DividerStruct,\n  HeadingStruct,\n  ImageStruct,\n  LinkStruct,\n  RowStruct,\n  SpinnerStruct,\n  TextStruct,\n  DropdownStruct,\n  OptionStruct,\n  ValueStruct,\n  TooltipStruct,\n  CheckboxStruct,\n  FooterStruct,\n  ContainerStruct,\n  CardStruct,\n]);\n\n/**\n * Check if a value is a JSX element.\n *\n * @param value - The value to check.\n * @returns True if the value is a JSX element, false otherwise.\n */\nexport function isJSXElement(value: unknown): value is JSXElement {\n  return is(value, JSXElementStruct);\n}\n\n/**\n * Check if a value is a JSX element, without validating all of its contents.\n * This is useful when you want to validate the structure of a value, but not\n * all the children.\n *\n * This should only be used when you are sure that the value is safe to use,\n * i.e., after using {@link isJSXElement}.\n *\n * @param value - The value to check.\n * @returns True if the value is a JSX element, false otherwise.\n */\nexport function isJSXElementUnsafe(value: unknown): value is JSXElement {\n  return (\n    isPlainObject(value) &&\n    hasProperty(value, 'type') &&\n    hasProperty(value, 'props') &&\n    hasProperty(value, 'key')\n  );\n}\n\n/**\n * Assert that a value is a JSX element.\n *\n * @param value - The value to check.\n * @throws If the value is not a JSX element.\n */\nexport function assertJSXElement(value: unknown): asserts value is JSXElement {\n  // TODO: We should use the error parsing utils from `snaps-utils` to improve\n  // the error messages. It currently includes colours and potentially other\n  // formatting that we might not want to include in the SDK.\n  if (!isJSXElement(value)) {\n    throw new Error(\n      `Expected a JSX element, but received ${JSON.stringify(\n        value,\n      )}. Please refer to the documentation for the supported JSX elements and their props.`,\n    );\n  }\n}\n","import type { AnyStruct, Infer, InferStructTuple } from '@metamask/superstruct';\nimport {\n  Struct,\n  define,\n  is,\n  literal as superstructLiteral,\n  union as superstructUnion,\n} from '@metamask/superstruct';\nimport { hasProperty, isPlainObject } from '@metamask/utils';\n\nimport type { EnumToUnion } from './helpers';\n\n/**\n * A wrapper of `superstruct`'s `literal` struct that also defines the name of\n * the struct as the literal value.\n *\n * This is useful for improving the error messages returned by `superstruct`.\n * For example, instead of returning an error like:\n *\n * ```\n * Expected the value to satisfy a union of `literal | literal`, but received: \\\"baz\\\"\n * ```\n *\n * This struct will return an error like:\n *\n * ```\n * Expected the value to satisfy a union of `\"foo\" | \"bar\"`, but received: \\\"baz\\\"\n * ```\n *\n * @param value - The literal value.\n * @returns The `superstruct` struct, which validates that the value is equal\n * to the literal value.\n */\nexport function literal<Type extends string | number | boolean>(value: Type) {\n  return define<Type>(\n    JSON.stringify(value),\n    superstructLiteral(value).validator,\n  );\n}\n\n/**\n * A wrapper of `superstruct`'s `union` struct that also defines the schema as\n * the union of the schemas of the structs.\n *\n * This is useful for improving the error messages returned by `superstruct`.\n *\n * @param structs - The structs to union.\n * @param structs.\"0\" - The first struct.\n * @param structs.\"1\" - The remaining structs.\n * @returns The `superstruct` struct, which validates that the value satisfies\n * one of the structs.\n */\nexport function union<Head extends AnyStruct, Tail extends AnyStruct[]>([\n  head,\n  ...tail\n]: [head: Head, ...tail: Tail]): Struct<\n  Infer<Head> | InferStructTuple<Tail>[number],\n  [head: Head, ...tail: Tail]\n> {\n  const struct = superstructUnion([head, ...tail]);\n\n  return new Struct({\n    ...struct,\n    schema: [head, ...tail],\n  });\n}\n\n/**\n * Superstruct struct for validating an enum value. This allows using both the\n * enum string values and the enum itself as values.\n *\n * @param constant - The enum to validate against.\n * @returns The superstruct struct.\n */\nexport function enumValue<Type extends string>(\n  constant: Type,\n): Struct<EnumToUnion<Type>, null> {\n  return literal(constant as EnumToUnion<Type>);\n}\n\n/**\n * Create a custom union struct that validates exclusively based on a `type` field.\n *\n * This should improve error messaging for unions with many structs in them.\n *\n * @param structs - The structs to union.\n * @returns The `superstruct` struct, which validates that the value satisfies\n * one of the structs.\n */\nexport function typedUnion<Head extends AnyStruct, Tail extends AnyStruct[]>(\n  structs: [head: Head, ...tail: Tail],\n): Struct<Infer<Head> | InferStructTuple<Tail>[number], null> {\n  return new Struct({\n    type: 'union',\n    schema: null,\n    *entries(value, context) {\n      if (!isPlainObject(value) || !hasProperty(value, 'type')) {\n        return;\n      }\n\n      const { type } = value;\n      const struct = structs.find(({ schema }) => is(type, schema.type));\n\n      if (!struct) {\n        return;\n      }\n\n      for (const entry of struct.entries(value, context)) {\n        yield entry;\n      }\n    },\n    validator(value, context) {\n      const types = structs.map(({ schema }) => schema.type.type);\n\n      if (\n        !isPlainObject(value) ||\n        !hasProperty(value, 'type') ||\n        typeof value.type !== 'string'\n      ) {\n        return `Expected type to be one of: ${types.join(\n          ', ',\n        )}, but received: undefined`;\n      }\n\n      const { type } = value;\n\n      const struct = structs.find(({ schema }) => is(type, schema.type));\n\n      if (struct) {\n        // This only validates the root of the struct, entries does the rest of the work.\n        return struct.validator(value, context);\n      }\n\n      return `Expected type to be one of: ${types.join(\n        ', ',\n      )}, but received: \"${type}\"`;\n    },\n  }) as unknown as Struct<Infer<Head> | InferStructTuple<Tail>[number], null>;\n}\n","import type {\n  AnyStruct,\n  EnumSchema,\n  Infer,\n  InferStructTuple,\n  IsExactMatch,\n  IsMatch,\n  IsRecord,\n  IsTuple,\n  Struct,\n  UnionToIntersection,\n} from '@metamask/superstruct';\n\nimport type { EmptyObject } from '../types';\nimport { union } from './structs';\n\n/**\n * Check if a type is a union. Infers `true` if it is a union, otherwise\n * `false`.\n */\ntype IsUnion<Type> = [Type] extends [UnionToIntersection<Type>] ? false : true;\n\n/**\n * Get a struct schema for a type.\n *\n * This is copied from `superstruct` but fixes some issues with the original\n * implementation.\n */\ntype StructSchema<Type> = IsUnion<Type> extends true\n  ? null\n  : [Type] extends [EmptyObject]\n  ? EmptyObject\n  : [Type] extends [string | undefined | null]\n  ? [Type] extends [`0x${string}`]\n    ? null\n    : [Type] extends [IsMatch<Type, string | undefined | null>]\n    ? null\n    : [Type] extends [IsUnion<Type>]\n    ? EnumSchema<Type>\n    : Type\n  : [Type] extends [number | undefined | null]\n  ? [Type] extends [IsMatch<Type, number | undefined | null>]\n    ? null\n    : [Type] extends [IsUnion<Type>]\n    ? EnumSchema<Type>\n    : Type\n  : [Type] extends [boolean]\n  ? [Type] extends [IsExactMatch<Type, boolean>]\n    ? null\n    : Type\n  : Type extends\n      | bigint\n      | symbol\n      | undefined\n      | null\n      // eslint-disable-next-line @typescript-eslint/ban-types\n      | Function\n      | Date\n      | Error\n      | RegExp\n      | Map<any, any>\n      | WeakMap<any, any>\n      | Set<any>\n      | WeakSet<any>\n      | Promise<any>\n  ? null\n  : Type extends (infer E)[]\n  ? Type extends IsTuple<Type>\n    ? null\n    : Struct<E>\n  : Type extends object\n  ? Type extends IsRecord<Type>\n    ? null\n    : {\n        [InnerKey in keyof Type]: Describe<Type[InnerKey]>;\n      }\n  : null;\n\n/**\n * Describe a struct type.\n */\nexport type Describe<Type> = Struct<Type, StructSchema<Type>>;\n\n/**\n * Create a union struct that uses `null` for the schema type, for better\n * compatibility with `Describe`.\n *\n * @param structs - The structs to union.\n * @returns The `superstruct` struct, which validates that the value satisfies\n * one of the structs.\n */\nexport function nullUnion<Head extends AnyStruct, Tail extends AnyStruct[]>(\n  structs: [head: Head, ...tail: Tail],\n): Struct<Infer<Head> | InferStructTuple<Tail>[number], null> {\n  return union(structs) as unknown as Struct<\n    Infer<Head> | InferStructTuple<Tail>[number],\n    null\n  >;\n}\n","import { refine, string } from '@metamask/superstruct';\n\n/**\n * Get a Struct that validates a string as a valid SVG.\n *\n * @returns A Struct that validates a string as a valid SVG.\n * @internal\n */\nexport function svg() {\n  return refine(string(), 'SVG', (value) => {\n    // This validation is intentionally very basic, we don't need to be that strict\n    // and merely have this extra validation as a helpful error if devs aren't\n    // passing in SVGs.\n    if (!value.includes('<svg')) {\n      return 'Value is not a valid SVG.';\n    }\n\n    return true;\n  });\n}\n","import type { JsonObject, Key, SnapComponent } from './component';\nimport { jsx } from './jsx-runtime';\nimport { assertJSXElement } from './validation';\n\n/**\n * The JSX runtime for Snaps SDK components. This function is used to render\n * Snap components into a format that can be used by the Snaps.\n *\n * This is the \"development\" version of the runtime, which includes additional\n * validation, which is otherwise handled by MetaMask. To use this runtime,\n * specify `@metamask/snaps-sdk` as import source for JSX, and use\n * `react-jsxdev` as the pragma.\n *\n * @param component - The component to render.\n * @param props - The props to pass to the component.\n * @param key - The key of the component.\n * @returns The rendered component.\n * @see https://www.typescriptlang.org/tsconfig/#jsx\n */\nexport function jsxDEV<Props extends JsonObject>(\n  component: SnapComponent<Props>,\n  props: Props,\n  key: Key | null,\n): unknown | null {\n  const element = jsx(component, props, key);\n  assertJSXElement(element);\n\n  return element;\n}\n"],"mappings":"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","names":["TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","is","string","hasProperty","isPlainObject","string","is","isPlainObject","hasProperty","element"]}