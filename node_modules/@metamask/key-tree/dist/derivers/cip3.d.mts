import type { DeriveChildKeyArgs } from "./index.mjs";
import { type Curve } from "../curves/index.mjs";
import { SLIP10Node } from "../SLIP10Node.mjs";
/**
 * CIP-3 https://github.com/cardano-foundation/CIPs/blob/09d7d8ee1bd64f7e6b20b5a6cae088039dce00cb/CIP-0003/CIP-0003.md.
 *
 * CIP-3 defines standards for deriving keys on Cardano.
 *
 * Key attributes.
 * - Root/Master key is derived from entropy, not seed. For this implementation we work with Icarus standard as it is the most widely used.
 * - See https://github.com/cardano-foundation/CIPs/blob/09d7d8ee1bd64f7e6b20b5a6cae088039dce00cb/CIP-0003/Icarus.md.
 *
 * - HD node consists of a 64 byte private key, 32 byte public key and 32 byte chain code.
 * - See https://github.com/cardano-foundation/CIPs/blob/09d7d8ee1bd64f7e6b20b5a6cae088039dce00cb/CIP-0003/CIP-0003.md#master-key-generation.
 *
 * - For derivation of BIP32 HD nodes, it uses modified version called BIP32-Ed25519.
 * - See https://input-output-hk.github.io/adrestia/static/Ed25519_BIP.pdf.
 */
/**
 * Reverses the order of bytes in a Uint8Array.
 *
 * Native BigInt uses big-endian. Since cip3(bip32Edd25519) uses little-endian.
 * We need to reverse the bytes and have separate functions for bigIntToBytes and bytesToBigInt.
 * .slice() is used just to make a copy of the array.
 *
 * @param bytes - The input Uint8Array.
 * @returns A new Uint8Array with the bytes in reversed order.
 */
export declare const toReversed: (bytes: Uint8Array) => Uint8Array;
/**
 * Converts an array of bytes to a BigInt.
 *
 * @param bytes - The array of bytes to convert.
 * @returns The BigInt representation of the bytes.
 */
export declare const bytesToBigInt: (bytes: Uint8Array) => bigint;
/**
 * Converts a BigInt to a byte array.
 *
 * @param bigInt - The BigInt to convert.
 * @returns The byte array representation of the BigInt.
 */
export declare const bigIntToBytes: (bigInt: bigint) => Uint8Array;
/**
 * Pads end of the given bytes array with zeros to a length of 32 bytes.
 *
 * @param bytes - The bytes array to pad.
 * @returns The padded bytes array.
 */
export declare const padEnd32Bytes: (bytes: Uint8Array) => Uint8Array;
/**
 * Truncates to first 28 bytes and multiplies by 8.
 *
 * @param bytes - Little-Endian big number in bytes.
 * @returns PadEnd32Bytes(left[0, 28] * 8)).
 */
export declare const trunc28Mul8: (bytes: Uint8Array) => Uint8Array;
/**
 * Does module 2^256.
 *
 * @param bytes - Little-Endian big number in bytes.
 * @returns PadEnd32Bytes(mod(bytes, 2^256))).
 */
export declare const mod2Pow256: (bytes: Uint8Array) => Uint8Array;
/**
 * Adds the left to the right.
 *
 * @param left - Left hand side Little-Endian big number.
 * @param right - Right hand side Little-Endian big number.
 * @returns PadEnd32Bytes(left + right).
 */
export declare const add: (left: Uint8Array, right: Uint8Array) => Uint8Array;
/**
 * Concat tag, key and childIndex.
 *
 * @param tag - Key specific tag.
 * @param key - Key.
 * @param childIndex - Child index.
 * @returns PadEnd32Bytes(left + right).
 */
export declare const getKeyExtension: (tag: number, key: Uint8Array, childIndex: number) => Uint8Array;
export declare type Cip3SupportedCurve = Extract<Curve, {
    name: 'ed25519Bip32';
}>;
declare type DeriveKeyBaseArgs = {
    childIndex: number;
};
declare type DeriveWithPrivateArgs = DeriveKeyBaseArgs & {
    parentNode: {
        privateKeyBytes: Uint8Array;
        chainCodeBytes: Uint8Array;
        publicKeyBytes: Uint8Array;
    };
    isHardened: boolean;
};
/**
 * Derives a private child key.
 *
 * Following "Section V. BIP32-ED25519: SPECIFICATION, C.1,2" in https://input-output-hk.github.io/adrestia/static/Ed25519_BIP.pdf.
 *
 * @param param1 - The parameters for deriving a child key.
 * @param param1.parentNode - The parent node containing private key, chain code, and public key.
 * @param param1.childIndex - The index of the child key.
 * @param param1.isHardened - Indicates if the child key is hardened.
 * @returns The derived child key.
 */
export declare const derivePrivateKey: ({ parentNode, childIndex, isHardened, }: DeriveWithPrivateArgs) => Promise<Uint8Array>;
declare type DeriveWithoutPrivateArgs = DeriveKeyBaseArgs & {
    parentNode: {
        chainCodeBytes: Uint8Array;
        publicKeyBytes: Uint8Array;
    };
    isHardened: false;
};
/**
 * Derives a child chainCode.
 *
 * Following "Section V. BIP32-ED25519: SPECIFICATION, C.3" in https://input-output-hk.github.io/adrestia/static/Ed25519_BIP.pdf.
 *
 * @param param1 - The parameters for deriving a child chainCode.
 * @param param1.parentNode - The parent node containing optionally a private key, chain code, and public key.
 * @param param1.childIndex - The index of the child key.
 * @param param1.isHardened - Indicates if the child key is hardened.
 * @returns The derived child chainCode.
 */
export declare const deriveChainCode: ({ parentNode, childIndex, isHardened, }: DeriveWithPrivateArgs | DeriveWithoutPrivateArgs) => Promise<Uint8Array>;
declare type DerivePublicKeyArgs = DeriveWithoutPrivateArgs & {
    curve: Cip3SupportedCurve;
};
/**
 * Derives a public key.
 *
 * Following "Section V. BIP32-ED25519: SPECIFICATION, D" in https://input-output-hk.github.io/adrestia/static/Ed25519_BIP.pdf.
 *
 * @param param1 - The parameters for deriving a child public key.
 * @param param1.parentNode - The parent node containing chain code, and public key.
 * @param param1.childIndex - The index of the child key.
 * @param param1.curve - Derivation curve.
 * @returns The derived child public key.
 */
export declare const derivePublicKey: ({ parentNode, childIndex, curve, }: DerivePublicKeyArgs) => Promise<Uint8Array>;
declare type Cip3DeriveChildKeyArgs = DeriveChildKeyArgs & {
    curve: Cip3SupportedCurve;
};
/**
 * Derive a SLIP-10 child key with a given path from a parent key.
 *
 * @param options - The options for deriving a child key.
 * @returns SLIP10Node.
 */
export declare function deriveChildKey(options: Cip3DeriveChildKeyArgs): Promise<SLIP10Node>;
export {};
//# sourceMappingURL=cip3.d.mts.map