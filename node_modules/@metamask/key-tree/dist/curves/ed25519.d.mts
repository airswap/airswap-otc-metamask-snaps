export declare const curve: Readonly<{
    readonly nBitLength: number;
    readonly nByteLength: number;
    readonly Fp: import("@noble/curves/abstract/modular").IField<bigint>;
    readonly n: bigint;
    readonly h: bigint;
    readonly hEff?: bigint | undefined;
    readonly Gx: bigint;
    readonly Gy: bigint;
    readonly allowInfinityPoint?: boolean | undefined;
    readonly a: bigint;
    readonly d: bigint;
    readonly hash: import("@noble/curves/abstract/utils").FHash;
    readonly randomBytes: (bytesLength?: number | undefined) => Uint8Array;
    readonly adjustScalarBytes?: ((bytes: Uint8Array) => Uint8Array) | undefined;
    readonly domain?: ((data: Uint8Array, ctx: Uint8Array, phflag: boolean) => Uint8Array) | undefined;
    readonly uvRatio?: ((u: bigint, v: bigint) => {
        isValid: boolean;
        value: bigint;
    }) | undefined;
    readonly prehash?: import("@noble/curves/abstract/utils").FHash | undefined;
    readonly mapToCurve?: ((scalar: bigint[]) => import("@noble/curves/abstract/curve").AffinePoint<bigint>) | undefined;
    readonly p: bigint;
}>;
export declare const name = "ed25519";
export declare const secret: Uint8Array;
export declare const isValidPrivateKey: (_privateKey: Uint8Array | string | bigint) => boolean;
export declare const deriveUnhardenedKeys = false;
export declare const publicKeyLength = 33;
export declare const getPublicKey: (privateKey: Uint8Array, _compressed?: boolean) => Uint8Array;
export declare const publicAdd: (_publicKey: Uint8Array, _tweak: Uint8Array) => Uint8Array;
export declare const compressPublicKey: (publicKey: Uint8Array) => Uint8Array;
export declare const decompressPublicKey: (publicKey: Uint8Array) => Uint8Array;
export declare const privateKeyLength = 32;
export declare const masterNodeGenerationSpec = "slip10";
export declare const compressedPublicKeyLength = 33;
//# sourceMappingURL=ed25519.d.mts.map