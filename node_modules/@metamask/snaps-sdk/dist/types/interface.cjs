"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InterfaceContextStruct = exports.ComponentOrElementStruct = exports.InterfaceStateStruct = exports.FormStateStruct = exports.StateStruct = void 0;
const superstruct_1 = require("@metamask/superstruct");
const utils_1 = require("@metamask/utils");
const internals_1 = require("../internals/index.cjs");
const jsx_1 = require("../jsx/index.cjs");
const ui_1 = require("../ui/index.cjs");
const handlers_1 = require("./handlers/index.cjs");
/**
 * To avoid typing problems with the interface state when manipulating it we
 * have to differentiate the state of a form (that will be contained inside the
 * root state) and the root state since a key in the root stat can contain
 * either the value of an input or a sub-state of a form.
 */
exports.StateStruct = (0, superstruct_1.union)([handlers_1.FileStruct, (0, superstruct_1.string)(), (0, superstruct_1.boolean)()]);
exports.FormStateStruct = (0, superstruct_1.record)((0, superstruct_1.string)(), (0, superstruct_1.nullable)(exports.StateStruct));
exports.InterfaceStateStruct = (0, superstruct_1.record)((0, superstruct_1.string)(), (0, superstruct_1.union)([exports.FormStateStruct, (0, superstruct_1.nullable)(exports.StateStruct)]));
exports.ComponentOrElementStruct = (0, internals_1.selectiveUnion)((value) => {
    if ((0, utils_1.isObject)(value) && !(0, utils_1.hasProperty)(value, 'props')) {
        return ui_1.ComponentStruct;
    }
    return jsx_1.RootJSXElementStruct;
});
exports.InterfaceContextStruct = (0, superstruct_1.record)((0, superstruct_1.string)(), utils_1.JsonStruct);
//# sourceMappingURL=interface.cjs.map