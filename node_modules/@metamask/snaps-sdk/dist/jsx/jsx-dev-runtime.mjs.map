{"version":3,"sources":["../../src/jsx/jsx-runtime.ts","../../src/jsx/validation.ts","../../src/internals/structs.ts","../../src/internals/jsx.ts","../../src/internals/svg.ts","../../src/jsx/jsx-dev-runtime.ts"],"sourcesContent":["import type { JsonObject, Key, SnapComponent } from './component';\n\n/**\n * The JSX runtime for Snaps SDK components. This function is used to render\n * Snap components into a format that can be used by the Snaps.\n *\n * This is the \"production\" version of the runtime, which does not include\n * additional validation, as it is handled by MetaMask. To use this runtime,\n * specify `@metamask/snaps-sdk` as import source for JSX, and use `react-jsx`\n * as the pragma.\n *\n * @param component - The component to render.\n * @param props - The props to pass to the component.\n * @param key - The key of the component.\n * @returns The rendered component.\n * @see https://www.typescriptlang.org/tsconfig/#jsx\n */\nexport function jsx<Props extends JsonObject>(\n  component: SnapComponent<Props>,\n  props: Props,\n  key: Key | null,\n): unknown | null {\n  if (typeof component === 'string') {\n    // If component is a string, it is a built-in HTML element. This is not\n    // supported in Snaps, so we throw an error.\n    throw new Error(\n      `An HTML element (\"${String(\n        component,\n      )}\") was used in a Snap component, which is not supported by Snaps UI. Please use one of the supported Snap components.`,\n    );\n  }\n\n  if (!component) {\n    // If component is undefined, a JSX fragment `<>...</>` was used, which is\n    // not supported in Snaps.\n    throw new Error(\n      'A JSX fragment was used in a Snap component, which is not supported by Snaps UI. Please use one of the supported Snap components.',\n    );\n  }\n\n  return component({ ...props, key });\n}\n\n/**\n * The JSX runtime for Snaps SDK components. This function is used to render\n * Snap components into a format that can be used by the Snaps.\n *\n * The `jsxs` function is used for rendering nested components.\n *\n * This is the \"production\" version of the runtime, which does not include\n * additional validation, as it is handled by MetaMask. To use this runtime,\n * specify `@metamask/snaps-sdk` as import source for JSX, and use `react-jsx`\n * as the pragma.\n *\n * @param component - The component to render.\n * @param props - The props to pass to the component.\n * @param key - The key of the component.\n * @returns The rendered component.\n * @see https://www.typescriptlang.org/tsconfig/#jsx\n */\nexport function jsxs<Props extends JsonObject>(\n  component: SnapComponent<Props>,\n  props: Props,\n  key: Key | null,\n): unknown | null {\n  return jsx(component, props, key);\n}\n","import type {\n  AnyStruct,\n  Infer,\n  InferStructTuple,\n  ObjectSchema,\n  Struct,\n} from '@metamask/superstruct';\nimport {\n  is,\n  boolean,\n  optional,\n  array,\n  lazy,\n  nullable,\n  number,\n  object,\n  record,\n  string,\n  tuple,\n} from '@metamask/superstruct';\nimport {\n  hasProperty,\n  HexChecksumAddressStruct,\n  isPlainObject,\n  JsonStruct,\n} from '@metamask/utils';\n\nimport type { Describe } from '../internals';\nimport { literal, nullUnion, svg, typedUnion } from '../internals';\nimport type { EmptyObject } from '../types';\nimport type {\n  GenericSnapElement,\n  JsonObject,\n  Key,\n  Nestable,\n  SnapElement,\n  SnapsChildren,\n  StringElement,\n} from './component';\nimport type {\n  AddressElement,\n  BoldElement,\n  BoxElement,\n  ButtonElement,\n  CheckboxElement,\n  CardElement,\n  CopyableElement,\n  DividerElement,\n  DropdownElement,\n  OptionElement,\n  FieldElement,\n  FormElement,\n  HeadingElement,\n  ImageElement,\n  InputElement,\n  ItalicElement,\n  JSXElement,\n  LinkElement,\n  RowElement,\n  SpinnerElement,\n  StandardFormattingElement,\n  TextElement,\n  TooltipElement,\n  ValueElement,\n  FileInputElement,\n  ContainerElement,\n  FooterElement,\n} from './components';\n\n/**\n * A struct for the {@link Key} type.\n */\nexport const KeyStruct: Describe<Key> = nullUnion([string(), number()]);\n\n/**\n * A struct for the {@link StringElement} type.\n */\nexport const StringElementStruct: Describe<StringElement> = children([\n  string(),\n]);\n\n/**\n * A struct for the {@link GenericSnapElement} type.\n */\nexport const ElementStruct: Describe<GenericSnapElement> = object({\n  type: string(),\n  props: record(string(), JsonStruct),\n  key: nullable(KeyStruct),\n});\n\n/**\n * A helper function for creating a struct for a {@link Nestable} type.\n *\n * @param struct - The struct for the type to test.\n * @returns The struct for the nestable type.\n */\nfunction nestable<Type, Schema>(\n  struct: Struct<Type, Schema>,\n): Struct<Nestable<Type>, any> {\n  const nestableStruct: Struct<Nestable<Type>> = nullUnion([\n    struct,\n    array(lazy(() => nestableStruct)),\n  ]);\n\n  return nestableStruct;\n}\n\n/**\n * A helper function for creating a struct which allows children of a specific\n * type, as well as `null` and `boolean`.\n *\n * @param structs - The structs to allow as children.\n * @returns The struct for the children.\n */\nfunction children<Head extends AnyStruct, Tail extends AnyStruct[]>(\n  structs: [head: Head, ...tail: Tail],\n): Struct<\n  Nestable<Infer<Head> | InferStructTuple<Tail>[number] | boolean | null>,\n  null\n> {\n  return nestable(nullable(nullUnion([...structs, boolean()])));\n}\n\n/**\n * A helper function for creating a struct for a JSX element.\n *\n * @param name - The name of the element.\n * @param props - The props of the element.\n * @returns The struct for the element.\n */\nfunction element<Name extends string, Props extends ObjectSchema = EmptyObject>(\n  name: Name,\n  props: Props = {} as Props,\n) {\n  return object({\n    type: literal(name) as unknown as Struct<Name, Name>,\n    props: object(props),\n    key: nullable(KeyStruct),\n  });\n}\n\n/**\n * A struct for the {@link ButtonElement} type.\n */\nexport const ButtonStruct: Describe<ButtonElement> = element('Button', {\n  children: StringElementStruct,\n  name: optional(string()),\n  type: optional(nullUnion([literal('button'), literal('submit')])),\n  variant: optional(nullUnion([literal('primary'), literal('destructive')])),\n  disabled: optional(boolean()),\n});\n\n/**\n * A struct for the {@link CheckboxElement} type.\n */\nexport const CheckboxStruct: Describe<CheckboxElement> = element('Checkbox', {\n  name: string(),\n  checked: optional(boolean()),\n  label: optional(string()),\n  variant: optional(nullUnion([literal('default'), literal('toggle')])),\n});\n\n/**\n * A struct for the {@link InputElement} type.\n */\nexport const InputStruct: Describe<InputElement> = element('Input', {\n  name: string(),\n  type: optional(\n    nullUnion([literal('text'), literal('password'), literal('number')]),\n  ),\n  value: optional(string()),\n  placeholder: optional(string()),\n});\n\n/**\n * A struct for the {@link OptionElement} type.\n */\nexport const OptionStruct: Describe<OptionElement> = element('Option', {\n  value: string(),\n  children: string(),\n});\n\n/**\n * A struct for the {@link DropdownElement} type.\n */\nexport const DropdownStruct: Describe<DropdownElement> = element('Dropdown', {\n  name: string(),\n  value: optional(string()),\n  children: children([OptionStruct]),\n});\n\n/**\n * A struct for the {@link FileInputElement} type.\n */\nexport const FileInputStruct: Describe<FileInputElement> = element(\n  'FileInput',\n  {\n    name: string(),\n    accept: nullUnion([optional(array(string()))]),\n    compact: optional(boolean()),\n  },\n);\n\n/**\n * A subset of JSX elements that represent the tuple Button + Input of the Field children.\n */\nconst BUTTON_INPUT = [InputStruct, ButtonStruct] as [\n  typeof InputStruct,\n  typeof ButtonStruct,\n];\n\n/**\n * A subset of JSX elements that are allowed as single children of the Field component.\n */\nconst FIELD_CHILDREN_ARRAY = [\n  InputStruct,\n  DropdownStruct,\n  FileInputStruct,\n  CheckboxStruct,\n] as [\n  typeof InputStruct,\n  typeof DropdownStruct,\n  typeof FileInputStruct,\n  typeof CheckboxStruct,\n];\n\n/**\n * A union of the allowed children of the Field component.\n * This is mainly used in the simulator for validation purposes.\n */\nexport const FieldChildUnionStruct = nullUnion([\n  ...FIELD_CHILDREN_ARRAY,\n  ...BUTTON_INPUT,\n]);\n\n/**\n * A subset of JSX elements that are allowed as children of the Field component.\n */\nconst FieldChildStruct = nullUnion([\n  tuple(BUTTON_INPUT),\n  ...FIELD_CHILDREN_ARRAY,\n]);\n\n/**\n * A struct for the {@link FieldElement} type.\n */\nexport const FieldStruct: Describe<FieldElement> = element('Field', {\n  label: optional(string()),\n  error: optional(string()),\n  children: FieldChildStruct,\n});\n\n/**\n * A subset of JSX elements that are allowed as children of the Form component.\n */\nexport const FormChildStruct = children(\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  [FieldStruct, lazy(() => BoxChildStruct)],\n) as unknown as Struct<SnapsChildren<GenericSnapElement>, null>;\n\n/**\n * A struct for the {@link FormElement} type.\n */\nexport const FormStruct: Describe<FormElement> = element('Form', {\n  children: FormChildStruct,\n  name: string(),\n});\n\n/**\n * A struct for the {@link BoldElement} type.\n */\nexport const BoldStruct: Describe<BoldElement> = element('Bold', {\n  children: children([\n    string(),\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    lazy(() => ItalicStruct) as unknown as Struct<\n      SnapElement<JsonObject, 'Italic'>\n    >,\n  ]),\n});\n\n/**\n * A struct for the {@link ItalicElement} type.\n */\nexport const ItalicStruct: Describe<ItalicElement> = element('Italic', {\n  children: children([\n    string(),\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    lazy(() => BoldStruct) as unknown as Struct<\n      SnapElement<JsonObject, 'Bold'>\n    >,\n  ]),\n});\n\nexport const FormattingStruct: Describe<StandardFormattingElement> = nullUnion([\n  BoldStruct,\n  ItalicStruct,\n]);\n\n/**\n * A struct for the {@link AddressElement} type.\n */\nexport const AddressStruct: Describe<AddressElement> = element('Address', {\n  address: HexChecksumAddressStruct,\n});\n\nexport const BoxChildrenStruct = children(\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  [lazy(() => BoxChildStruct)],\n) as unknown as Struct<SnapsChildren<GenericSnapElement>, null>;\n\n/**\n * A struct for the {@link BoxElement} type.\n */\nexport const BoxStruct: Describe<BoxElement> = element('Box', {\n  children: BoxChildrenStruct,\n  direction: optional(nullUnion([literal('horizontal'), literal('vertical')])),\n  alignment: optional(\n    nullUnion([\n      literal('start'),\n      literal('center'),\n      literal('end'),\n      literal('space-between'),\n      literal('space-around'),\n    ]),\n  ),\n});\n\n/**\n * A subset of JSX elements that are allowed as children of the Footer component.\n * This set should include a single button or a tuple of two buttons.\n */\nexport const FooterChildStruct = nullUnion([\n  tuple([ButtonStruct, ButtonStruct]),\n  ButtonStruct,\n]);\n\n/**\n * A struct for the {@link FooterElement} type.\n */\nexport const FooterStruct: Describe<FooterElement> = element('Footer', {\n  children: FooterChildStruct,\n});\n\n/**\n * A subset of JSX elements that are allowed as children of the Container component.\n * This set should include a single Box or a tuple of a Box and a Footer component.\n */\nexport const ContainerChildStruct = nullUnion([\n  tuple([BoxStruct, FooterStruct]),\n  BoxStruct,\n]);\n\n/**\n * A struct for the {@link ContainerElement} type.\n */\nexport const ContainerStruct: Describe<ContainerElement> = element(\n  'Container',\n  {\n    children: ContainerChildStruct,\n  },\n);\n\n/**\n * A struct for the {@link CopyableElement} type.\n */\nexport const CopyableStruct: Describe<CopyableElement> = element('Copyable', {\n  value: string(),\n  sensitive: optional(boolean()),\n});\n\n/**\n * A struct for the {@link DividerElement} type.\n */\nexport const DividerStruct: Describe<DividerElement> = element('Divider');\n\n/**\n * A struct for the {@link ValueElement} type.\n */\nexport const ValueStruct: Describe<ValueElement> = element('Value', {\n  value: string(),\n  extra: string(),\n});\n\n/**\n * A struct for the {@link CardElement} type.\n */\nexport const CardStruct: Describe<CardElement> = element('Card', {\n  image: optional(string()),\n  title: string(),\n  description: optional(string()),\n  value: string(),\n  extra: optional(string()),\n});\n\n/**\n * A struct for the {@link HeadingElement} type.\n */\nexport const HeadingStruct: Describe<HeadingElement> = element('Heading', {\n  children: StringElementStruct,\n});\n\n/**\n * A struct for the {@link ImageElement} type.\n */\nexport const ImageStruct: Describe<ImageElement> = element('Image', {\n  src: svg(),\n  alt: optional(string()),\n});\n\n/**\n * A struct for the {@link LinkElement} type.\n */\nexport const LinkStruct: Describe<LinkElement> = element('Link', {\n  href: string(),\n  children: children([FormattingStruct, string()]),\n});\n\n/**\n * A struct for the {@link TextElement} type.\n */\nexport const TextStruct: Describe<TextElement> = element('Text', {\n  children: children([string(), BoldStruct, ItalicStruct, LinkStruct]),\n  alignment: optional(\n    nullUnion([literal('start'), literal('center'), literal('end')]),\n  ),\n});\n\n/**\n * A subset of JSX elements that are allowed as children of the Tooltip component.\n * This set should include all text components and the Image.\n */\nexport const TooltipChildStruct = nullUnion([\n  TextStruct,\n  BoldStruct,\n  ItalicStruct,\n  LinkStruct,\n  ImageStruct,\n  boolean(),\n]);\n\n/**\n * A subset of JSX elements that are allowed as content of the Tooltip component.\n * This set should include all text components.\n */\nexport const TooltipContentStruct = nullUnion([\n  TextStruct,\n  BoldStruct,\n  ItalicStruct,\n  LinkStruct,\n  string(),\n]);\n\n/**\n * A struct for the {@link TooltipElement} type.\n */\nexport const TooltipStruct: Describe<TooltipElement> = element('Tooltip', {\n  children: nullable(TooltipChildStruct),\n  content: TooltipContentStruct,\n});\n\n/**\n * A struct for the {@link RowElement} type.\n */\nexport const RowStruct: Describe<RowElement> = element('Row', {\n  label: string(),\n  children: nullUnion([AddressStruct, ImageStruct, TextStruct, ValueStruct]),\n  variant: optional(\n    nullUnion([literal('default'), literal('warning'), literal('critical')]),\n  ),\n  tooltip: optional(string()),\n});\n\n/**\n * A struct for the {@link SpinnerElement} type.\n */\nexport const SpinnerStruct: Describe<SpinnerElement> = element('Spinner');\n\n/**\n * A subset of JSX elements that are allowed as children of the Box component.\n * This set includes all components, except components that need to be nested in\n * another component (e.g., Field must be contained in a Form).\n */\nexport const BoxChildStruct = typedUnion([\n  AddressStruct,\n  BoldStruct,\n  BoxStruct,\n  ButtonStruct,\n  CopyableStruct,\n  DividerStruct,\n  DropdownStruct,\n  FileInputStruct,\n  FormStruct,\n  HeadingStruct,\n  InputStruct,\n  ImageStruct,\n  ItalicStruct,\n  LinkStruct,\n  RowStruct,\n  SpinnerStruct,\n  TextStruct,\n  TooltipStruct,\n  CheckboxStruct,\n  CardStruct,\n]);\n\n/**\n * For now, the allowed JSX elements at the root are the same as the allowed\n * children of the Box component.\n */\nexport const RootJSXElementStruct = nullUnion([\n  BoxChildStruct,\n  ContainerStruct,\n]);\n\n/**\n * A struct for the {@link JSXElement} type.\n */\nexport const JSXElementStruct: Describe<JSXElement> = typedUnion([\n  ButtonStruct,\n  InputStruct,\n  FileInputStruct,\n  FieldStruct,\n  FormStruct,\n  BoldStruct,\n  ItalicStruct,\n  AddressStruct,\n  BoxStruct,\n  CopyableStruct,\n  DividerStruct,\n  HeadingStruct,\n  ImageStruct,\n  LinkStruct,\n  RowStruct,\n  SpinnerStruct,\n  TextStruct,\n  DropdownStruct,\n  OptionStruct,\n  ValueStruct,\n  TooltipStruct,\n  CheckboxStruct,\n  FooterStruct,\n  ContainerStruct,\n  CardStruct,\n]);\n\n/**\n * Check if a value is a JSX element.\n *\n * @param value - The value to check.\n * @returns True if the value is a JSX element, false otherwise.\n */\nexport function isJSXElement(value: unknown): value is JSXElement {\n  return is(value, JSXElementStruct);\n}\n\n/**\n * Check if a value is a JSX element, without validating all of its contents.\n * This is useful when you want to validate the structure of a value, but not\n * all the children.\n *\n * This should only be used when you are sure that the value is safe to use,\n * i.e., after using {@link isJSXElement}.\n *\n * @param value - The value to check.\n * @returns True if the value is a JSX element, false otherwise.\n */\nexport function isJSXElementUnsafe(value: unknown): value is JSXElement {\n  return (\n    isPlainObject(value) &&\n    hasProperty(value, 'type') &&\n    hasProperty(value, 'props') &&\n    hasProperty(value, 'key')\n  );\n}\n\n/**\n * Assert that a value is a JSX element.\n *\n * @param value - The value to check.\n * @throws If the value is not a JSX element.\n */\nexport function assertJSXElement(value: unknown): asserts value is JSXElement {\n  // TODO: We should use the error parsing utils from `snaps-utils` to improve\n  // the error messages. It currently includes colours and potentially other\n  // formatting that we might not want to include in the SDK.\n  if (!isJSXElement(value)) {\n    throw new Error(\n      `Expected a JSX element, but received ${JSON.stringify(\n        value,\n      )}. Please refer to the documentation for the supported JSX elements and their props.`,\n    );\n  }\n}\n","import type { AnyStruct, Infer, InferStructTuple } from '@metamask/superstruct';\nimport {\n  Struct,\n  define,\n  is,\n  literal as superstructLiteral,\n  union as superstructUnion,\n} from '@metamask/superstruct';\nimport { hasProperty, isPlainObject } from '@metamask/utils';\n\nimport type { EnumToUnion } from './helpers';\n\n/**\n * A wrapper of `superstruct`'s `literal` struct that also defines the name of\n * the struct as the literal value.\n *\n * This is useful for improving the error messages returned by `superstruct`.\n * For example, instead of returning an error like:\n *\n * ```\n * Expected the value to satisfy a union of `literal | literal`, but received: \\\"baz\\\"\n * ```\n *\n * This struct will return an error like:\n *\n * ```\n * Expected the value to satisfy a union of `\"foo\" | \"bar\"`, but received: \\\"baz\\\"\n * ```\n *\n * @param value - The literal value.\n * @returns The `superstruct` struct, which validates that the value is equal\n * to the literal value.\n */\nexport function literal<Type extends string | number | boolean>(value: Type) {\n  return define<Type>(\n    JSON.stringify(value),\n    superstructLiteral(value).validator,\n  );\n}\n\n/**\n * A wrapper of `superstruct`'s `union` struct that also defines the schema as\n * the union of the schemas of the structs.\n *\n * This is useful for improving the error messages returned by `superstruct`.\n *\n * @param structs - The structs to union.\n * @param structs.\"0\" - The first struct.\n * @param structs.\"1\" - The remaining structs.\n * @returns The `superstruct` struct, which validates that the value satisfies\n * one of the structs.\n */\nexport function union<Head extends AnyStruct, Tail extends AnyStruct[]>([\n  head,\n  ...tail\n]: [head: Head, ...tail: Tail]): Struct<\n  Infer<Head> | InferStructTuple<Tail>[number],\n  [head: Head, ...tail: Tail]\n> {\n  const struct = superstructUnion([head, ...tail]);\n\n  return new Struct({\n    ...struct,\n    schema: [head, ...tail],\n  });\n}\n\n/**\n * Superstruct struct for validating an enum value. This allows using both the\n * enum string values and the enum itself as values.\n *\n * @param constant - The enum to validate against.\n * @returns The superstruct struct.\n */\nexport function enumValue<Type extends string>(\n  constant: Type,\n): Struct<EnumToUnion<Type>, null> {\n  return literal(constant as EnumToUnion<Type>);\n}\n\n/**\n * Create a custom union struct that validates exclusively based on a `type` field.\n *\n * This should improve error messaging for unions with many structs in them.\n *\n * @param structs - The structs to union.\n * @returns The `superstruct` struct, which validates that the value satisfies\n * one of the structs.\n */\nexport function typedUnion<Head extends AnyStruct, Tail extends AnyStruct[]>(\n  structs: [head: Head, ...tail: Tail],\n): Struct<Infer<Head> | InferStructTuple<Tail>[number], null> {\n  return new Struct({\n    type: 'union',\n    schema: null,\n    *entries(value, context) {\n      if (!isPlainObject(value) || !hasProperty(value, 'type')) {\n        return;\n      }\n\n      const { type } = value;\n      const struct = structs.find(({ schema }) => is(type, schema.type));\n\n      if (!struct) {\n        return;\n      }\n\n      for (const entry of struct.entries(value, context)) {\n        yield entry;\n      }\n    },\n    validator(value, context) {\n      const types = structs.map(({ schema }) => schema.type.type);\n\n      if (\n        !isPlainObject(value) ||\n        !hasProperty(value, 'type') ||\n        typeof value.type !== 'string'\n      ) {\n        return `Expected type to be one of: ${types.join(\n          ', ',\n        )}, but received: undefined`;\n      }\n\n      const { type } = value;\n\n      const struct = structs.find(({ schema }) => is(type, schema.type));\n\n      if (struct) {\n        // This only validates the root of the struct, entries does the rest of the work.\n        return struct.validator(value, context);\n      }\n\n      return `Expected type to be one of: ${types.join(\n        ', ',\n      )}, but received: \"${type}\"`;\n    },\n  }) as unknown as Struct<Infer<Head> | InferStructTuple<Tail>[number], null>;\n}\n","import type {\n  AnyStruct,\n  EnumSchema,\n  Infer,\n  InferStructTuple,\n  IsExactMatch,\n  IsMatch,\n  IsRecord,\n  IsTuple,\n  Struct,\n  UnionToIntersection,\n} from '@metamask/superstruct';\n\nimport type { EmptyObject } from '../types';\nimport { union } from './structs';\n\n/**\n * Check if a type is a union. Infers `true` if it is a union, otherwise\n * `false`.\n */\ntype IsUnion<Type> = [Type] extends [UnionToIntersection<Type>] ? false : true;\n\n/**\n * Get a struct schema for a type.\n *\n * This is copied from `superstruct` but fixes some issues with the original\n * implementation.\n */\ntype StructSchema<Type> = IsUnion<Type> extends true\n  ? null\n  : [Type] extends [EmptyObject]\n  ? EmptyObject\n  : [Type] extends [string | undefined | null]\n  ? [Type] extends [`0x${string}`]\n    ? null\n    : [Type] extends [IsMatch<Type, string | undefined | null>]\n    ? null\n    : [Type] extends [IsUnion<Type>]\n    ? EnumSchema<Type>\n    : Type\n  : [Type] extends [number | undefined | null]\n  ? [Type] extends [IsMatch<Type, number | undefined | null>]\n    ? null\n    : [Type] extends [IsUnion<Type>]\n    ? EnumSchema<Type>\n    : Type\n  : [Type] extends [boolean]\n  ? [Type] extends [IsExactMatch<Type, boolean>]\n    ? null\n    : Type\n  : Type extends\n      | bigint\n      | symbol\n      | undefined\n      | null\n      // eslint-disable-next-line @typescript-eslint/ban-types\n      | Function\n      | Date\n      | Error\n      | RegExp\n      | Map<any, any>\n      | WeakMap<any, any>\n      | Set<any>\n      | WeakSet<any>\n      | Promise<any>\n  ? null\n  : Type extends (infer E)[]\n  ? Type extends IsTuple<Type>\n    ? null\n    : Struct<E>\n  : Type extends object\n  ? Type extends IsRecord<Type>\n    ? null\n    : {\n        [InnerKey in keyof Type]: Describe<Type[InnerKey]>;\n      }\n  : null;\n\n/**\n * Describe a struct type.\n */\nexport type Describe<Type> = Struct<Type, StructSchema<Type>>;\n\n/**\n * Create a union struct that uses `null` for the schema type, for better\n * compatibility with `Describe`.\n *\n * @param structs - The structs to union.\n * @returns The `superstruct` struct, which validates that the value satisfies\n * one of the structs.\n */\nexport function nullUnion<Head extends AnyStruct, Tail extends AnyStruct[]>(\n  structs: [head: Head, ...tail: Tail],\n): Struct<Infer<Head> | InferStructTuple<Tail>[number], null> {\n  return union(structs) as unknown as Struct<\n    Infer<Head> | InferStructTuple<Tail>[number],\n    null\n  >;\n}\n","import { refine, string } from '@metamask/superstruct';\n\n/**\n * Get a Struct that validates a string as a valid SVG.\n *\n * @returns A Struct that validates a string as a valid SVG.\n * @internal\n */\nexport function svg() {\n  return refine(string(), 'SVG', (value) => {\n    // This validation is intentionally very basic, we don't need to be that strict\n    // and merely have this extra validation as a helpful error if devs aren't\n    // passing in SVGs.\n    if (!value.includes('<svg')) {\n      return 'Value is not a valid SVG.';\n    }\n\n    return true;\n  });\n}\n","import type { JsonObject, Key, SnapComponent } from './component';\nimport { jsx } from './jsx-runtime';\nimport { assertJSXElement } from './validation';\n\n/**\n * The JSX runtime for Snaps SDK components. This function is used to render\n * Snap components into a format that can be used by the Snaps.\n *\n * This is the \"development\" version of the runtime, which includes additional\n * validation, which is otherwise handled by MetaMask. To use this runtime,\n * specify `@metamask/snaps-sdk` as import source for JSX, and use\n * `react-jsxdev` as the pragma.\n *\n * @param component - The component to render.\n * @param props - The props to pass to the component.\n * @param key - The key of the component.\n * @returns The rendered component.\n * @see https://www.typescriptlang.org/tsconfig/#jsx\n */\nexport function jsxDEV<Props extends JsonObject>(\n  component: SnapComponent<Props>,\n  props: Props,\n  key: Key | null,\n): unknown | null {\n  const element = jsx(component, props, key);\n  assertJSXElement(element);\n\n  return element;\n}\n"],"mappings":"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","names":["is","string","hasProperty","isPlainObject","string","is","element"]}